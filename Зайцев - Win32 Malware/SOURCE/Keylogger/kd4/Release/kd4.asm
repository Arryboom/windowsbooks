; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\kd4.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0O@DAJADFOL@ScanCode?3?5?$CFx?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@MLLCBMNM@Key?5Down?5?$CIKEY_MAKE?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03IKGEINEE@?$CFs?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@OPNLEKPA@Key?5Up?5?$CIKEY_BREAK?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08BPDOJMNO@?$CIKEY_E0?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08BOPMPGOJ@?$CIKEY_E1?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1CO@NPEEKIFM@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAK?$AAe?$AAy?$AAb?$AAo?$AAa?$AAr?$AAd?$AAC?$AAl?$AAa?$AAs@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CM@JIELBGM@InstallKeyboardFilter?3?5IoCreateD@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DD@JOIINKDE@InstallKeyboardFilter?3?5error?0?5Io@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1CA@NBKOJFPL@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAK?$AAD?$AA4?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BI@HDNPAHPM@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAK?$AAD?$AA4?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CJ@JPLNHOOH@DriverEntry?3?5IoCreateSymbolicLin@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _IsEqualGUID@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnReadCompletion@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DriverDispatchRead@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DriverDispatchGeneral@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InstallKeyboardFilter@@YGJPAU_DRIVER_OBJECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DriverUnload@@YGXPAU_DRIVER_OBJECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DriverEntry@@YGJPAU_DRIVER_OBJECT@@PAU_UNICODE_STRING@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?pGlobalDevExt@@3PAU_DEVICE_EXTENSION@@A	; pGlobalDevExt
_BSS	SEGMENT
?pGlobalDevExt@@3PAU_DEVICE_EXTENSION@@A DD 01H DUP (?)	; pGlobalDevExt
_BSS	ENDS
PUBLIC	?OnReadCompletion@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@PAX@Z ; OnReadCompletion
PUBLIC	??_C@_0O@DAJADFOL@ScanCode?3?5?$CFx?5?$AA@	; `string'
PUBLIC	??_C@_0BE@MLLCBMNM@Key?5Down?5?$CIKEY_MAKE?$CJ?$AA@ ; `string'
PUBLIC	??_C@_03IKGEINEE@?$CFs?5?$AA@			; `string'
PUBLIC	??_C@_0BD@OPNLEKPA@Key?5Up?5?$CIKEY_BREAK?$CJ?$AA@ ; `string'
PUBLIC	??_C@_08BPDOJMNO@?$CIKEY_E0?$CJ?$AA@		; `string'
PUBLIC	??_C@_08BOPMPGOJ@?$CIKEY_E1?$CJ?$AA@		; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
EXTRN	_DbgPrint:NEAR
;	COMDAT ??_C@_0O@DAJADFOL@ScanCode?3?5?$CFx?5?$AA@
; File e:\delphi5\delphi7\projects\bhv\kd4\kd4.cpp
CONST	SEGMENT
??_C@_0O@DAJADFOL@ScanCode?3?5?$CFx?5?$AA@ DB 'ScanCode: %x ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MLLCBMNM@Key?5Down?5?$CIKEY_MAKE?$CJ?$AA@
CONST	SEGMENT
??_C@_0BE@MLLCBMNM@Key?5Down?5?$CIKEY_MAKE?$CJ?$AA@ DB 'Key Down (KEY_MAK'
	DB	'E)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OPNLEKPA@Key?5Up?5?$CIKEY_BREAK?$CJ?$AA@
CONST	SEGMENT
??_C@_0BD@OPNLEKPA@Key?5Up?5?$CIKEY_BREAK?$CJ?$AA@ DB 'Key Up (KEY_BREAK)'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08BPDOJMNO@?$CIKEY_E0?$CJ?$AA@
CONST	SEGMENT
??_C@_08BPDOJMNO@?$CIKEY_E0?$CJ?$AA@ DB '(KEY_E0)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08BOPMPGOJ@?$CIKEY_E1?$CJ?$AA@
CONST	SEGMENT
??_C@_08BOPMPGOJ@?$CIKEY_E1?$CJ?$AA@ DB '(KEY_E1)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03IKGEINEE@?$CFs?5?$AA@
CONST	SEGMENT
??_C@_03IKGEINEE@?$CFs?5?$AA@ DB '%s ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?OnReadCompletion@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@PAX@Z
_TEXT	SEGMENT
_pDeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_Context$ = 16						; size = 4
?OnReadCompletion@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@PAX@Z PROC NEAR ; OnReadCompletion, COMDAT

; 14   : {

	push	ebx

; 15   : 	// Если Status = STATUS_SUCCESS, то в буфере IRP есть данные о нажатиях клавиш
; 16   : 	if(Irp->IoStatus.Status == STATUS_SUCCESS)

	mov	ebx, DWORD PTR _Irp$[esp]
	mov	eax, DWORD PTR [ebx+24]
	test	eax, eax
	jne	SHORT $L9993

; 17   : 	{
; 18   : 		// Указатель на буфер (эта структура декларирована в ntddkbd.h
; 19   : 		PKEYBOARD_INPUT_DATA KeyData = (PKEYBOARD_INPUT_DATA)Irp->AssociatedIrp.SystemBuffer;

	mov	ecx, DWORD PTR [ebx+12]

; 20   : 		// Кол-во данных о нажатиях в буфере
; 21   : 		int KeyDataCount = Irp->IoStatus.Information / sizeof(KEYBOARD_INPUT_DATA);

	mov	eax, -1431655765			; aaaaaaabH
	mul	DWORD PTR [ebx+28]
	shr	edx, 3

; 22   :         // Вывод информации из буфера через DbgPrint 
; 23   : 		for(int i = 0; i < KeyDataCount; i++)

	test	edx, edx
	jle	SHORT $L9993
	push	esi
	push	edi
	lea	esi, DWORD PTR [ecx+4]
	mov	edi, edx
$L9991:

; 24   : 		{
; 25   : 			DbgPrint("ScanCode: %x ", KeyData[i].MakeCode);

	movzx	eax, WORD PTR [esi-2]
	push	eax
	push	OFFSET FLAT:??_C@_0O@DAJADFOL@ScanCode?3?5?$CFx?5?$AA@
	call	_DbgPrint

; 26   :             // Флаги
; 27   : 			switch (KeyData[i].Flags) {

	movzx	eax, WORD PTR [esi]
	add	esp, 8
	cmp	eax, 4
	ja	SHORT $L9996
	jmp	DWORD PTR $L10110[eax*4]
$L9999:

; 28   : 			 case KEY_MAKE:
; 29   : 				 DbgPrint("%s ","Key Down (KEY_MAKE)");

	push	OFFSET FLAT:??_C@_0BE@MLLCBMNM@Key?5Down?5?$CIKEY_MAKE?$CJ?$AA@

; 30   : 				 break;

	jmp	SHORT $L10109
$L10002:

; 31   : 			 case KEY_BREAK:
; 32   : 				 DbgPrint("%s ","Key Up (KEY_BREAK)");

	push	OFFSET FLAT:??_C@_0BD@OPNLEKPA@Key?5Up?5?$CIKEY_BREAK?$CJ?$AA@

; 33   : 				 break;

	jmp	SHORT $L10109
$L10004:

; 34   : 			 case KEY_E0:
; 35   : 				 DbgPrint("%s ","(KEY_E0)");

	push	OFFSET FLAT:??_C@_08BPDOJMNO@?$CIKEY_E0?$CJ?$AA@

; 36   : 				 break;

	jmp	SHORT $L10109
$L10006:

; 37   : 			 case KEY_E1:
; 38   : 				 DbgPrint("%s ","(KEY_E1)");

	push	OFFSET FLAT:??_C@_08BOPMPGOJ@?$CIKEY_E1?$CJ?$AA@
$L10109:
	push	OFFSET FLAT:??_C@_03IKGEINEE@?$CFs?5?$AA@
	call	_DbgPrint
	add	esp, 8
$L9996:

; 39   : 				 break;
; 40   : 			}			
; 41   : 			DbgPrint("\n");

	push	OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
	call	_DbgPrint
	add	esp, 4
	add	esi, 12					; 0000000cH
	dec	edi
	jne	SHORT $L9991
	pop	edi
	pop	esi
$L9993:

; 42   : 		}		
; 43   : 	}
; 44   : 
; 45   : 	// Постановка IRP в очередь (если необходимо)
; 46   : 	if(Irp->PendingReturned)

	mov	al, BYTE PTR [ebx+33]
	test	al, al
	je	SHORT $L10108

; 47   : 		IoMarkIrpPending(Irp);

	mov	eax, DWORD PTR [ebx+96]
	or	BYTE PTR [eax+3], 1
$L10108:

; 48   : 
; 49   : 	return Irp->IoStatus.Status;

	mov	eax, DWORD PTR [ebx+24]
	pop	ebx

; 50   : }

	ret	12					; 0000000cH
	npad	1
$L10110:
	DD	$L9999
	DD	$L10002
	DD	$L10004
	DD	$L9996
	DD	$L10006
?OnReadCompletion@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@PAX@Z ENDP ; OnReadCompletion
_TEXT	ENDS
PUBLIC	?DriverDispatchRead@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z ; DriverDispatchRead
EXTRN	__imp_@IofCallDriver@8:NEAR
; Function compile flags: /Ogty
;	COMDAT ?DriverDispatchRead@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z
_TEXT	SEGMENT
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
?DriverDispatchRead@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z PROC NEAR ; DriverDispatchRead, COMDAT

; 55   :     PIO_STACK_LOCATION currentIrpStack = IoGetCurrentIrpStackLocation(Irp);

	mov	edx, DWORD PTR _Irp$[esp-4]
	push	esi
	mov	esi, DWORD PTR [edx+96]
	push	edi

; 56   : 	PIO_STACK_LOCATION nextIrpStack    = IoGetNextIrpStackLocation(Irp);

	lea	edi, DWORD PTR [esi-36]

; 57   :     *nextIrpStack = *currentIrpStack;

	mov	ecx, 9
	rep movsd

; 58   : 
; 59   : 	// Встановили в IRP нашу callback-функцию завершения
; 60   : 	IoSetCompletionRoutine(Irp, OnReadCompletion, DeviceObject, TRUE, TRUE, TRUE);

	mov	eax, DWORD PTR [edx+96]
	mov	ecx, DWORD PTR _DeviceObject$[esp+4]
	sub	eax, 36					; 00000024H
	mov	DWORD PTR [eax+28], OFFSET FLAT:?OnReadCompletion@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@PAX@Z ; OnReadCompletion
	mov	DWORD PTR [eax+32], ecx
	mov	BYTE PTR [eax+3], 224			; 000000e0H

; 61   :     // Передаем IRP драйверу
; 62   :     return IoCallDriver(pGlobalDevExt->KbdDevice, Irp);	

	mov	eax, DWORD PTR ?pGlobalDevExt@@3PAU_DEVICE_EXTENSION@@A ; pGlobalDevExt
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR __imp_@IofCallDriver@8
	pop	edi
	pop	esi

; 63   : 
; 64   : }

	ret	8
?DriverDispatchRead@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z ENDP ; DriverDispatchRead
_TEXT	ENDS
PUBLIC	?DriverDispatchGeneral@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z ; DriverDispatchGeneral
; Function compile flags: /Ogty
;	COMDAT ?DriverDispatchGeneral@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z
_TEXT	SEGMENT
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
?DriverDispatchGeneral@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z PROC NEAR ; DriverDispatchGeneral, COMDAT

; 68   : 	// Пропускаем все IRP без обработки 
; 69   : 	IoSkipCurrentIrpStackLocation(Irp);

	mov	edx, DWORD PTR _Irp$[esp-4]
	mov	cl, BYTE PTR [edx+35]
	mov	eax, DWORD PTR [edx+96]
	inc	cl
	add	eax, 36					; 00000024H
	mov	BYTE PTR [edx+35], cl
	mov	DWORD PTR [edx+96], eax

; 70   :     return IoCallDriver(pGlobalDevExt->KbdDevice, Irp);

	mov	eax, DWORD PTR ?pGlobalDevExt@@3PAU_DEVICE_EXTENSION@@A ; pGlobalDevExt
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR __imp_@IofCallDriver@8

; 71   : }

	ret	8
?DriverDispatchGeneral@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z ENDP ; DriverDispatchGeneral
_TEXT	ENDS
PUBLIC	?InstallKeyboardFilter@@YGJPAU_DRIVER_OBJECT@@@Z ; InstallKeyboardFilter
PUBLIC	??_C@_1CO@NPEEKIFM@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAK?$AAe?$AAy?$AAb?$AAo?$AAa?$AAr?$AAd?$AAC?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??_C@_0CM@JIELBGM@InstallKeyboardFilter?3?5IoCreateD@ ; `string'
PUBLIC	??_C@_0DD@JOIINKDE@InstallKeyboardFilter?3?5error?0?5Io@ ; `string'
EXTRN	__imp__IoCreateDevice@28:NEAR
EXTRN	__imp__IoDeleteDevice@4:NEAR
EXTRN	__imp__RtlInitUnicodeString@8:NEAR
EXTRN	__imp__IoAttachDevice@12:NEAR
;	COMDAT ??_C@_1CO@NPEEKIFM@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAK?$AAe?$AAy?$AAb?$AAo?$AAa?$AAr?$AAd?$AAC?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1CO@NPEEKIFM@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAK?$AAe?$AAy?$AAb?$AAo?$AAa?$AAr?$AAd?$AAC?$AAl?$AAa?$AAs@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'\', 00H, 'K', 00H, 'e', 00H, 'y', 00H, 'b', 00H, 'o', 00H, 'a'
	DB	00H, 'r', 00H, 'd', 00H, 'C', 00H, 'l', 00H, 'a', 00H, 's', 00H
	DB	's', 00H, '0', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@JIELBGM@InstallKeyboardFilter?3?5IoCreateD@
CONST	SEGMENT
??_C@_0CM@JIELBGM@InstallKeyboardFilter?3?5IoCreateD@ DB 'InstallKeyboard'
	DB	'Filter: IoCreateDevice error', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@JOIINKDE@InstallKeyboardFilter?3?5error?0?5Io@
CONST	SEGMENT
??_C@_0DD@JOIINKDE@InstallKeyboardFilter?3?5error?0?5Io@ DB 'InstallKeybo'
	DB	'ardFilter: error, IoAttachDevice error', 00H ; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?InstallKeyboardFilter@@YGJPAU_DRIVER_OBJECT@@@Z
_TEXT	SEGMENT
_DeviceObject$ = -12					; size = 4
_ntUnicodeString$ = -8					; size = 8
_DriverObject$ = 8					; size = 4
?InstallKeyboardFilter@@YGJPAU_DRIVER_OBJECT@@@Z PROC NEAR ; InstallKeyboardFilter, COMDAT

; 75   : {

	sub	esp, 12					; 0000000cH
	push	esi

; 76   :     UNICODE_STRING          ntUnicodeString;
; 77   :     NTSTATUS                ntStatus;
; 78   :     PDEVICE_OBJECT          DeviceObject        = NULL;
; 79   : 
; 80   :     // Устанавливаем фильтр на \Device\KeyboardClass0
; 81   :     RtlInitUnicodeString( &ntUnicodeString, L"\\Device\\KeyboardClass0" );

	push	OFFSET FLAT:??_C@_1CO@NPEEKIFM@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAK?$AAe?$AAy?$AAb?$AAo?$AAa?$AAr?$AAd?$AAC?$AAl?$AAa?$AAs@
	lea	eax, DWORD PTR _ntUnicodeString$[esp+20]
	push	eax
	mov	DWORD PTR _DeviceObject$[esp+24], 0
	call	DWORD PTR __imp__RtlInitUnicodeString@8

; 82   :     ntStatus = IoCreateDevice( DriverObject,
; 83   :                  0,
; 84   :                  NULL,
; 85   :                  FILE_DEVICE_KEYBOARD,
; 86   :                  0,
; 87   :                  FALSE,
; 88   :                  &DeviceObject );

	mov	edx, DWORD PTR _DriverObject$[esp+12]
	lea	ecx, DWORD PTR _DeviceObject$[esp+16]
	push	ecx
	push	0
	push	0
	push	11					; 0000000bH
	push	0
	push	0
	push	edx
	call	DWORD PTR __imp__IoCreateDevice@28
	mov	esi, eax

; 89   : 
; 90   :     if( !NT_SUCCESS(ntStatus) ) {

	test	esi, esi
	jge	SHORT $L10033

; 91   :         DbgPrint("InstallKeyboardFilter: IoCreateDevice error");

	push	OFFSET FLAT:??_C@_0CM@JIELBGM@InstallKeyboardFilter?3?5IoCreateD@
	call	_DbgPrint
	add	esp, 4

; 92   :         return ntStatus;

	mov	eax, esi
	pop	esi

; 108  : }

	add	esp, 12					; 0000000cH
	ret	4
$L10033:

; 93   :     }
; 94   :     //
; 95   :     // Установка флага DO_BUFFERED_IO    
; 96   :     DeviceObject->Flags |= DO_BUFFERED_IO;

	mov	eax, DWORD PTR _DeviceObject$[esp+16]
	or	DWORD PTR [eax+28], 4

; 97   :     //
; 98   :     // Подключение нашего фильтра
; 99   :     ntStatus = IoAttachDevice( DeviceObject, &ntUnicodeString, &pGlobalDevExt->KbdDevice );

	mov	eax, DWORD PTR ?pGlobalDevExt@@3PAU_DEVICE_EXTENSION@@A ; pGlobalDevExt
	mov	edx, DWORD PTR _DeviceObject$[esp+16]
	push	eax
	lea	ecx, DWORD PTR _ntUnicodeString$[esp+20]
	push	ecx
	push	edx
	call	DWORD PTR __imp__IoAttachDevice@12
	mov	esi, eax

; 100  :     if( !NT_SUCCESS(ntStatus) ) {

	test	esi, esi
	jge	SHORT $L10036

; 101  :         DbgPrint("InstallKeyboardFilter: error, IoAttachDevice error");

	push	OFFSET FLAT:??_C@_0DD@JOIINKDE@InstallKeyboardFilter?3?5error?0?5Io@
	call	_DbgPrint

; 102  :         IoDeleteDevice( DeviceObject );    

	mov	eax, DWORD PTR _DeviceObject$[esp+20]
	add	esp, 4
	push	eax
	call	DWORD PTR __imp__IoDeleteDevice@4

; 103  :         return ntStatus;

	mov	eax, esi
	pop	esi

; 108  : }

	add	esp, 12					; 0000000cH
	ret	4
$L10036:

; 104  :     }
; 105  :     pGlobalDevExt->KbdFilterDevice = DeviceObject;

	mov	ecx, DWORD PTR _DeviceObject$[esp+16]
	mov	edx, DWORD PTR ?pGlobalDevExt@@3PAU_DEVICE_EXTENSION@@A ; pGlobalDevExt
	mov	DWORD PTR [edx+4], ecx

; 106  : 
; 107  :     return STATUS_SUCCESS;

	xor	eax, eax
	pop	esi

; 108  : }

	add	esp, 12					; 0000000cH
	ret	4
?InstallKeyboardFilter@@YGJPAU_DRIVER_OBJECT@@@Z ENDP	; InstallKeyboardFilter
_TEXT	ENDS
PUBLIC	?DriverUnload@@YGXPAU_DRIVER_OBJECT@@@Z		; DriverUnload
PUBLIC	??_C@_1CA@NBKOJFPL@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAK?$AAD?$AA4?$AA?$AA@ ; `string'
EXTRN	__imp__IoDeleteSymbolicLink@4:NEAR
EXTRN	__imp__IoDetachDevice@4:NEAR
;	COMDAT ??_C@_1CA@NBKOJFPL@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAK?$AAD?$AA4?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@NBKOJFPL@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAK?$AAD?$AA4?$AA?$AA@ DB '\'
	DB	00H, 'D', 00H, 'o', 00H, 's', 00H, 'D', 00H, 'e', 00H, 'v', 00H
	DB	'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'K', 00H, 'D'
	DB	00H, '4', 00H, 00H, 00H			; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?DriverUnload@@YGXPAU_DRIVER_OBJECT@@@Z
_TEXT	SEGMENT
_usSymbolicLinkName$ = -8				; size = 8
_DriverObject$ = 8					; size = 4
?DriverUnload@@YGXPAU_DRIVER_OBJECT@@@Z PROC NEAR	; DriverUnload, COMDAT

; 112  : {

	sub	esp, 8
	push	esi

; 113  :     UNICODE_STRING usSymbolicLinkName;
; 114  :     
; 115  :     // Удаляем ссылку
; 116  :     RtlInitUnicodeString(&usSymbolicLinkName, L"\\DosDevices\\KD4");

	push	OFFSET FLAT:??_C@_1CA@NBKOJFPL@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAK?$AAD?$AA4?$AA?$AA@
	lea	eax, DWORD PTR _usSymbolicLinkName$[esp+16]
	push	eax
	call	DWORD PTR __imp__RtlInitUnicodeString@8

; 117  :     IoDeleteSymbolicLink(&usSymbolicLinkName);

	lea	ecx, DWORD PTR _usSymbolicLinkName$[esp+12]
	push	ecx
	call	DWORD PTR __imp__IoDeleteSymbolicLink@4

; 118  :     // Отключаем фильтр
; 119  :     IoDetachDevice(pGlobalDevExt->KbdDevice);

	mov	edx, DWORD PTR ?pGlobalDevExt@@3PAU_DEVICE_EXTENSION@@A ; pGlobalDevExt
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR __imp__IoDetachDevice@4

; 120  : 	// Удаляем созданные нами устройства
; 121  :     IoDeleteDevice(pGlobalDevExt->KbdFilterDevice);    

	mov	ecx, DWORD PTR ?pGlobalDevExt@@3PAU_DEVICE_EXTENSION@@A ; pGlobalDevExt
	mov	edx, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR __imp__IoDeleteDevice@4
	push	edx
	call	esi

; 122  :     IoDeleteDevice(DriverObject->DeviceObject);

	mov	eax, DWORD PTR _DriverObject$[esp+8]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	esi
	pop	esi

; 123  :  }

	add	esp, 8
	ret	4
?DriverUnload@@YGXPAU_DRIVER_OBJECT@@@Z ENDP		; DriverUnload
_TEXT	ENDS
PUBLIC	?DriverEntry@@YGJPAU_DRIVER_OBJECT@@PAU_UNICODE_STRING@@@Z ; DriverEntry
PUBLIC	??_C@_1BI@HDNPAHPM@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAK?$AAD?$AA4?$AA?$AA@ ; `string'
PUBLIC	??_C@_0CJ@JPLNHOOH@DriverEntry?3?5IoCreateSymbolicLin@ ; `string'
EXTRN	__imp__IoCreateSymbolicLink@8:NEAR
;	COMDAT ??_C@_1BI@HDNPAHPM@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAK?$AAD?$AA4?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@HDNPAHPM@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAK?$AAD?$AA4?$AA?$AA@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'\', 00H, 'K', 00H, 'D', 00H, '4', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@JPLNHOOH@DriverEntry?3?5IoCreateSymbolicLin@
CONST	SEGMENT
??_C@_0CJ@JPLNHOOH@DriverEntry?3?5IoCreateSymbolicLin@ DB 'DriverEntry: I'
	DB	'oCreateSymbolicLink error', 0aH, 00H	; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?DriverEntry@@YGJPAU_DRIVER_OBJECT@@PAU_UNICODE_STRING@@@Z
_TEXT	SEGMENT
_DeviceObject$ = -20					; size = 4
_usDeviceNameUnicodeString$ = -16			; size = 8
_usDeviceLinkUnicodeString$ = -8			; size = 8
_DriverObject$ = 8					; size = 4
_RegistryPath$ = 12					; size = 4
?DriverEntry@@YGJPAU_DRIVER_OBJECT@@PAU_UNICODE_STRING@@@Z PROC NEAR ; DriverEntry, COMDAT

; 128  : {

	sub	esp, 20					; 00000014H
	push	esi

; 129  :     PDEVICE_OBJECT         DeviceObject        = NULL;
; 130  :     NTSTATUS               ntStatus;
; 131  :     UNICODE_STRING         usDeviceNameUnicodeString;
; 132  :     UNICODE_STRING         usDeviceLinkUnicodeString;
; 133  : 
; 134  :     
; 135  :     // Подготовка Unicode строк
; 136  :     RtlInitUnicodeString (&usDeviceNameUnicodeString,
; 137  :                           L"\\Device\\KD4");

	mov	esi, DWORD PTR __imp__RtlInitUnicodeString@8
	push	OFFSET FLAT:??_C@_1BI@HDNPAHPM@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAK?$AAD?$AA4?$AA?$AA@
	lea	eax, DWORD PTR _usDeviceNameUnicodeString$[esp+28]
	push	eax
	mov	DWORD PTR _DeviceObject$[esp+32], 0
	call	esi

; 138  :     RtlInitUnicodeString (&usDeviceLinkUnicodeString,
; 139  :                           L"\\DosDevices\\KD4" );

	push	OFFSET FLAT:??_C@_1CA@NBKOJFPL@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAK?$AAD?$AA4?$AA?$AA@
	lea	ecx, DWORD PTR _usDeviceLinkUnicodeString$[esp+28]
	push	ecx
	call	esi

; 140  :     // Создание устройства
; 141  :     ntStatus = IoCreateDevice (DriverObject,
; 142  :                                sizeof(DEVICE_EXTENSION),
; 143  :                                &usDeviceNameUnicodeString,
; 144  :                                FILE_DEVICE_UNKNOWN,
; 145  :                                0,
; 146  :                                TRUE,
; 147  :                                &DeviceObject);

	mov	esi, DWORD PTR _DriverObject$[esp+20]
	lea	edx, DWORD PTR _DeviceObject$[esp+24]
	push	edx
	push	1
	push	0
	push	34					; 00000022H
	lea	eax, DWORD PTR _usDeviceNameUnicodeString$[esp+40]
	push	eax
	push	8
	push	esi
	call	DWORD PTR __imp__IoCreateDevice@28

; 148  : 
; 149  :     if (!NT_SUCCESS(ntStatus)) {

	test	eax, eax

; 150  :         return ntStatus;

	jl	$L10047

; 151  :     }
; 152  : 	// Запомним указатель на DeviceObject->DeviceExtension для его применения в обработчиках
; 153  :     pGlobalDevExt = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;

	mov	ecx, DWORD PTR _DeviceObject$[esp+24]
	mov	edx, DWORD PTR [ecx+40]
	push	edi

; 154  :     
; 155  :     // Создание символьной ссылки     
; 156  :     ntStatus = IoCreateSymbolicLink (&usDeviceLinkUnicodeString,
; 157  :                                      &usDeviceNameUnicodeString );

	lea	eax, DWORD PTR _usDeviceNameUnicodeString$[esp+28]
	push	eax
	lea	ecx, DWORD PTR _usDeviceLinkUnicodeString$[esp+32]
	push	ecx
	mov	DWORD PTR ?pGlobalDevExt@@3PAU_DEVICE_EXTENSION@@A, edx ; pGlobalDevExt
	call	DWORD PTR __imp__IoCreateSymbolicLink@8
	mov	edi, eax

; 158  :     if (!NT_SUCCESS(ntStatus)) {

	test	edi, edi
	jge	SHORT $L10058

; 159  : 		DbgPrint("DriverEntry: IoCreateSymbolicLink error\n");

	push	OFFSET FLAT:??_C@_0CJ@JPLNHOOH@DriverEntry?3?5IoCreateSymbolicLin@
	call	_DbgPrint

; 160  :         IoDeleteDevice(DeviceObject);

	mov	edx, DWORD PTR _DeviceObject$[esp+32]
	add	esp, 4
	push	edx
	call	DWORD PTR __imp__IoDeleteDevice@4

; 174  : 	// Отдельный обработчик - для IRP_MJ_READ
; 175  : 	DriverObject->MajorFunction[IRP_MJ_READ] = DriverDispatchRead;
; 176  : 	DriverObject->DriverUnload = DriverUnload;
; 177  :         
; 178  :     return ntStatus;

	mov	eax, edi
	pop	edi
	pop	esi

; 179  : }

	add	esp, 20					; 00000014H
	ret	8
$L10058:

; 161  :         return ntStatus;
; 162  :     }
; 163  :     
; 164  :     // Создание и подключение фильтра    
; 165  :     ntStatus = InstallKeyboardFilter( DriverObject );

	push	esi
	call	?InstallKeyboardFilter@@YGJPAU_DRIVER_OBJECT@@@Z ; InstallKeyboardFilter
	mov	edi, eax

; 166  :     if(!NT_SUCCESS(ntStatus)) {

	test	edi, edi
	jge	SHORT $L10061

; 167  :       IoDeleteDevice (DeviceObject);  

	mov	eax, DWORD PTR _DeviceObject$[esp+28]
	push	eax
	call	DWORD PTR __imp__IoDeleteDevice@4

; 174  : 	// Отдельный обработчик - для IRP_MJ_READ
; 175  : 	DriverObject->MajorFunction[IRP_MJ_READ] = DriverDispatchRead;
; 176  : 	DriverObject->DriverUnload = DriverUnload;
; 177  :         
; 178  :     return ntStatus;

	mov	eax, edi
	pop	edi
	pop	esi

; 179  : }

	add	esp, 20					; 00000014H
	ret	8
$L10061:

; 168  :       return ntStatus;
; 169  :     }
; 170  : 
; 171  :     // Подключение обработчика-ретранслятора ко всем функциям
; 172  : 	for(int i = 0; i < IRP_MJ_MAXIMUM_FUNCTION; i++)
; 173  : 		DriverObject->MajorFunction[i] = DriverDispatchGeneral;

	mov	eax, OFFSET FLAT:?DriverDispatchGeneral@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z ; DriverDispatchGeneral
	mov	DWORD PTR [esi+56], eax
	mov	DWORD PTR [esi+60], eax
	mov	DWORD PTR [esi+64], eax
	mov	DWORD PTR [esi+68], eax
	mov	DWORD PTR [esi+72], eax
	mov	DWORD PTR [esi+76], eax
	mov	DWORD PTR [esi+80], eax
	mov	DWORD PTR [esi+84], eax
	mov	DWORD PTR [esi+88], eax
	mov	DWORD PTR [esi+92], eax
	mov	DWORD PTR [esi+96], eax
	mov	DWORD PTR [esi+100], eax
	mov	DWORD PTR [esi+104], eax
	mov	DWORD PTR [esi+108], eax
	mov	DWORD PTR [esi+112], eax
	mov	DWORD PTR [esi+116], eax
	mov	DWORD PTR [esi+120], eax
	mov	DWORD PTR [esi+124], eax
	mov	DWORD PTR [esi+128], eax
	mov	DWORD PTR [esi+132], eax
	mov	DWORD PTR [esi+136], eax
	mov	DWORD PTR [esi+140], eax
	mov	DWORD PTR [esi+144], eax
	mov	DWORD PTR [esi+148], eax
	mov	DWORD PTR [esi+152], eax
	mov	DWORD PTR [esi+156], eax
	mov	DWORD PTR [esi+160], eax

; 174  : 	// Отдельный обработчик - для IRP_MJ_READ
; 175  : 	DriverObject->MajorFunction[IRP_MJ_READ] = DriverDispatchRead;
; 176  : 	DriverObject->DriverUnload = DriverUnload;
; 177  :         
; 178  :     return ntStatus;

	mov	eax, edi
	mov	DWORD PTR [esi+68], OFFSET FLAT:?DriverDispatchRead@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z ; DriverDispatchRead
	mov	DWORD PTR [esi+52], OFFSET FLAT:?DriverUnload@@YGXPAU_DRIVER_OBJECT@@@Z ; DriverUnload
	pop	edi
$L10047:
	pop	esi

; 179  : }

	add	esp, 20					; 00000014H
	ret	8
?DriverEntry@@YGJPAU_DRIVER_OBJECT@@PAU_UNICODE_STRING@@@Z ENDP ; DriverEntry
_TEXT	ENDS
END
