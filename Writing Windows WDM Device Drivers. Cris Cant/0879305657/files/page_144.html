<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
	<html>
		<head>
			<title>page_144</title>
			<link rel="stylesheet" href="reset.css" type="text/css" media="all">
			<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
		</head>
		<body>
		<table summary="top nav" border="0" width="100%">
			<tr>
				<td align="left" width="30%" style="background: #EEF3E2"><a style="color: blue; font-size: 120%; font-weight: bold; text-decoration: none; font-family: verdana;" href="page_143.html">&lt;&nbsp;previous page</a></td>
				<td id="ebook_previous" align="center" width="40%" style="background: #EEF3E2"><strong style="color: #2F4F4F; font-size: 120%;">page_144</strong></td>
				<td align="right" width="30%" style="background: #EEF3E2"><a style="color: blue; font-size: 120%; font-weight: bold; text-decoration: none; font-family: verdana;" href="page_145.html">next page&nbsp;&gt;</a></td>
			</tr>
		
			<tr>
				<td id="ebook_page" align="left" colspan="3" style="background: #ffffff; padding: 20px;">
    

<table border="0" width="100%" cellpadding="0"><tr><td align="center">
  <table border="0" cellpadding="2" cellspacing="0" width="100%"><tr><td align="left"></td>
  <td align="right"></td>
  </tr></table></td>
</tr><tr><td align="left">



<p>
</p><table border="0" cellspacing="0" cellpadding="0" width="100%"><tr><td align="right"><font face="Times New Roman, Times, Serif" size="2" color="#FF0000">Page 144</font></td></tr></table><table border="0" cellspacing="0" cellpadding="0"><tr><td rowspan="5"></td>
  <td colspan="3" height="12"></td>
  <td rowspan="5"></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td></td>
  <td><font face="Times New Roman, Times, Serif" size="3">you only hold a spin lock for a short time. The DDK recommends that you never hold a spin lock for more than 25 microseconds.</font></td>
<td></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td colspan="3" height="1"></td>
</tr></table><table border="0" cellspacing="0" cellpadding="0"><tr><td rowspan="5"></td>
  <td colspan="3" height="12"></td>
  <td rowspan="5"></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td></td>
  <td><font face="Times New Roman, Times, Serif" size="3">As shown in the code example, you must provide a pointer to a KIRQL variable in the call to </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">KeAcquireSpinLock</font><font face="Times New Roman, Times, Serif" size="3">. This stores the original IRQL level before it is raised (if necessary) to </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">DISPATCH_LEVEL</font><font face="Times New Roman, Times, Serif" size="3">. The call to </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">KeReleaseSpinLock</font><font face="Times New Roman, Times, Serif" size="3"> lowers the IRQL if necessary. If you are certain that your code is working at </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">DISPATCH_LEVEL</font><font face="Times New Roman, Times, Serif" size="3">, you can use the </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">KeAcquireSpinLockAtDpcLeve</font><font face="Times New Roman, Times, Serif" size="3">l and </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">KeReleaseSpinLockFromDpcLevel</font><font face="Times New Roman, Times, Serif" size="3"> routines for better performance.</font></td>
<td></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td colspan="3" height="1"></td>
</tr></table><table border="0" cellspacing="0" cellpadding="0"><tr><td rowspan="5"></td>
  <td colspan="3" height="12"></td>
  <td rowspan="5"></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td></td>
  <td><font face="Times New Roman, Times, Serif" size="3">The </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">Wdm1</font><font face="Times New Roman, Times, Serif" size="3"> driver acquires the </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">BufferLock</font><font face="Times New Roman, Times, Serif" size="3"> spin lock for the duration of any accesses to the </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">Buffer</font><font face="Times New Roman, Times, Serif" size="3"> and </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">BufferSize</font><font face="Times New Roman, Times, Serif" size="3"> variables. Do not access paged code or data while holding a spin lock, as the system will almost certainly crash. Definitely do not exit a main dispatch routine while holding a spin lock.</font></td>
<td></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td colspan="3" height="1"></td>
</tr></table><table border="0" cellspacing="0" cellpadding="0"><tr><td rowspan="5"></td>
  <td colspan="3" height="12"></td>
  <td rowspan="5"></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td></td>
  <td><font face="Times New Roman, Times, Serif" size="3">Write Algorithm</font></td>
<td></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td colspan="3" height="1"></td>
</tr></table><table border="0" cellspacing="0" cellpadding="0"><tr><td rowspan="5"></td>
  <td colspan="3" height="12"></td>
  <td rowspan="5"></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td></td>
  <td><font face="Times New Roman, Times, Serif" size="3">The write dispatch stores the write data in the shared memory buffer, starting from the given file pointer. It extends the buffer, if necessary.</font></td>
<td></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td colspan="3" height="1"></td>
</tr></table><table border="0" cellspacing="0" cellpadding="0"><tr><td rowspan="5"></td>
  <td colspan="3" height="12"></td>
  <td rowspan="5"></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td></td>
  <td><font face="Times New Roman, Times, Serif" size="3">If there is no buffer at all, or the buffer needs to be extended, </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">ExAllocatePool</font><font face="Times New Roman, Times, Serif" size="3"> is called to allocate some nonpaged memory. Notice that the algorithm checks for a NULL return value and copes as best as it can.</font></td>
<td></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td colspan="3" height="1"></td>
</tr></table><table border="0" cellspacing="0" cellpadding="0"><tr><td rowspan="5"></td>
  <td colspan="3" height="12"></td>
  <td rowspan="5"></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td></td>
  <td><font face="Times New Roman, Times, Serif" size="3">A new memory buffer is zeroed using </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">RtlZeroMemory</font><font face="Times New Roman, Times, Serif" size="3">. If an old shorter buffer exists, it is copied to the start of the new buffer using </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">RtlCopyMemory</font><font face="Times New Roman, Times, Serif" size="3">. </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">RtlMoveMemory</font><font face="Times New Roman, Times, Serif" size="3"> can be used if the source and destination pointers overlap. The old buffer is removed with </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">ExFreePool</font><font face="Times New Roman, Times, Serif" size="3">.</font></td>
<td></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td colspan="3" height="1"></td>
</tr></table><table border="0" cellspacing="0" cellpadding="0"><tr><td rowspan="5"></td>
  <td colspan="3" height="12"></td>
  <td rowspan="5"></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td></td>
  <td><font face="Times New Roman, Times, Serif" size="3">Finally, </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">Wdm1Write</font><font face="Times New Roman, Times, Serif" size="3"> copies the data from the user buffer using </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">RtlCopyMemory</font><font face="Times New Roman, Times, Serif" size="3">. As </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">Wdm1</font><font face="Times New Roman, Times, Serif" size="3"> uses Buffered I/O, it can simply copy the data from </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">Irp-&gt;AssociatedIrp.SystemBuffer</font><font face="Times New Roman, Times, Serif" size="3">.</font></td>
<td></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td colspan="3" height="1"></td>
</tr></table><table border="0" cellspacing="0" cellpadding="0"><tr><td rowspan="5"></td>
  <td colspan="3" height="12"></td>
  <td rowspan="5"></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td></td>
  <td><font face="Times New Roman, Times, Serif" size="3">This algorithm is fairly crude, because the buffer may have to be reallocated often. A much-enhanced version of </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">Wdm1</font><font face="Times New Roman, Times, Serif" size="3"> could implement a RAM disk.</font></td>
<td></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td colspan="3" height="1"></td>
</tr></table><table border="0" cellspacing="0" cellpadding="0"><tr><td rowspan="5"></td>
  <td colspan="3" height="12"></td>
  <td rowspan="5"></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td></td>
  <td><font face="Times New Roman, Times, Serif" size="3">The driver unload routine frees any shared memory buffer.</font></td>
<td></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td colspan="3" height="1"></td>
</tr></table><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td height="12"></td></tr><tr><td>
<table cellspacing="0" border="0" width="278" cellpadding="4"><tr><td valign="top"><font face="Courier New, Courier, Mono New, Courier, Mono" size="2">if( Buffer!=NULL<br />
    ExFreePool(Buffer</font></td></tr></table></td></tr></table><br /><table border="0" cellspacing="0" cellpadding="0"><tr><td rowspan="5"></td>
  <td colspan="3" height="12"></td>
  <td rowspan="5"></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td></td>
  <td><font face="Times New Roman, Times, Serif" size="3"><i>Read</i></font></td>
<td></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td colspan="3" height="1"></td>
</tr></table><table border="0" cellspacing="0" cellpadding="0"><tr><td rowspan="5"></td>
  <td colspan="3" height="12"></td>
  <td rowspan="5"></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td></td>
  <td><font face="Times New Roman, Times, Serif" size="3">The read dispatch routine for </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">Wdm1</font><font face="Times New Roman, Times, Serif" size="3">, </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">Wdm1Read</font><font face="Times New Roman, Times, Serif" size="3">, is simpler than the write handler. It acquires the spin lock while it accesses the global variables. The required number of bytes are copied to the user's buffer at </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">Irp-&gt;AssociatedIrp.SystemBuffer</font><font face="Times New Roman, Times, Serif" size="3">. If the user requests more data than is in the buffer, the request is truncated.</font></td>
<td></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td colspan="3" height="1"></td>
</tr></table><table border="0" cellspacing="0" cellpadding="0"><tr><td rowspan="5"></td>
  <td colspan="3" height="12"></td>
  <td rowspan="5"></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td></td>
  <td><font face="Times New Roman, Times, Serif" size="3"><i>IOCTL</i></font></td>
<td></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td colspan="3" height="1"></td>
</tr></table><table border="0" cellspacing="0" cellpadding="0"><tr><td rowspan="5"></td>
  <td colspan="3" height="12"></td>
  <td rowspan="5"></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td></td>
  <td><font face="Times New Roman, Times, Serif" size="3">The </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">Wdm1DeviceControl</font><font face="Times New Roman, Times, Serif" size="3"> dispatch routine handles the four IOCTLs defined for </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">Wdm1</font><font face="Times New Roman, Times, Serif" size="3"> devices: Zero the buffer, Remove the Buffer, Get the buffer size, and Get the buffer.</font></td>
<td></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td colspan="3" height="1"></td>
</tr></table><table border="0" cellspacing="0" cellpadding="0"><tr><td rowspan="5"></td>
  <td colspan="3" height="12"></td>
  <td rowspan="5"></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td></td>
  <td><font face="Times New Roman, Times, Serif" size="3">All these IOCTLs use Buffered I/O, so any input and output data is found at </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">Irp-&gt;AssociatedIrp.SystemBuffer</font><font face="Times New Roman, Times, Serif" size="3">. As usual, the routine acquires the shared buffer spin lock for the duration of the call. The actual implementation of each IOCTL is straightforward. The Get buffer size and Get buffer handlers check that the output buffer is large enough; if not, they return </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">STATUS_INVALID_PARAMETER</font><font face="Times New Roman, Times, Serif" size="3">.</font><font face="Times New Roman, Times, Serif" size="3" color="#FFFF00"></font></td>
<td></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td colspan="3" height="1"></td>
</tr></table>







</td>
</tr></table><p><font size="0">
</font></p>
 




  </td>
			</tr>
	
			<tr>
				<td align="left" width="30%" style="background: #EEF3E2"><a style="color: blue; font-size: 120%; font-weight: bold; text-decoration: none; font-family: verdana;" href="page_143.html">&lt;&nbsp;previous page</a></td>
				<td id="ebook_next" align="center" width="40%" style="background: #EEF3E2"><strong style="color: #2F4F4F; font-size: 120%;">page_144</strong></td>
				<td align="right" width="30%" style="background: #EEF3E2"><a style="color: blue; font-size: 120%; font-weight: bold; text-decoration: none; font-family: verdana;" href="page_145.html">next page&nbsp;&gt;</a></td>
			</tr>
		</table>
		</body>
	</html>