library rootkit_lib;
uses
  Windows,
  SysUtils,
  Classes,
  TlHelp32,
  afxCodeHook;

type
 // Информация о перехваченной функции
 TInterceptInfo = record
  LibraryName   : string;  // Имя DLL
  FunctionName  : string;  // Имя функции
  FunctionAddr  : Pointer; // Адрес функции
  HookAddr      : Pointer; // Адрес перехватчика
  FunctCode     : packed array [0..20] of byte; // Первые байты кода функции
  FunctCodeSize : byte;   // Размер кода функции, перемещенного руткитом
  HookBuf       : packed array [0..20] of byte; // Первые команды функции + JMP
  HookJMP       : packed array [0..4] of byte; // JMP на перехватчик 
 end;

var
 HookHandle   : hHook;      // Handle, возвращаемый SetWindowsHookEx
 MessageBoxInterceptInfo    : TInterceptInfo;

// Модификация машинного кода функции
function SetHookCode(InterceptInfo : TInterceptInfo; ASetHook : boolean) : boolean;
var
 Tmp, OldProtect     : dword;
begin
 // 1. Настройка защиты
 VirtualProtect(InterceptInfo.FunctionAddr, InterceptInfo.FunctCodeSize, PAGE_EXECUTE_READWRITE, OldProtect);
 // 2. Запись в первые байты машинного кода функции
 if ASetHook then
  Result := WriteProcessMemory(GetCurrentProcess, InterceptInfo.FunctionAddr,
                     @InterceptInfo.HookJMP[0], 5, Tmp)
 else
  Result := WriteProcessMemory(GetCurrentProcess, InterceptInfo.FunctionAddr,
                     @InterceptInfo.FunctCode[0], InterceptInfo.FunctCodeSize, Tmp);
 // 3. Восстановление атрибутов защиты
 VirtualProtect(InterceptInfo.FunctionAddr, InterceptInfo.FunctCodeSize, OldProtect, Tmp);
end;

function GetCodeSize(APtr : pointer) : integer;
begin
 // Вызов функции из afxCodeHook.pas
 Result := SizeOfCode(APtr);
end;

function InterceptFunctionEx(ALibName, AFunctName : string; var InterceptInfo : TInterceptInfo; HookFunct: Pointer) : boolean;
var
 Tmp     : dword;
 JMP_Rel : dword;
begin
 Result := false;
 // 1. Поиск адреса фукции
 InterceptInfo.FunctionAddr := GetProcAddress(GetModuleHandle(PChar(ALibName)), PChar(AFunctName));
 if InterceptInfo.FunctionAddr = nil then exit;
 // 2. Сохранение параметров в структуре
 InterceptInfo.LibraryName  := ALibName;
 InterceptInfo.FunctionName := AFunctName;
 InterceptInfo.HookAddr     := HookFunct;
 // 3. Определение размера копируемых данных
 InterceptInfo.FunctCodeSize := 0;
 while InterceptInfo.FunctCodeSize < 5 do begin
  Tmp := GetCodeSize(pointer(dword(InterceptInfo.FunctionAddr) + InterceptInfo.FunctCodeSize));
  if Tmp <= 0 then exit;
  inc(InterceptInfo.FunctCodeSize, Tmp);
 end;
 // 4. Считывание машинного кода функции
 Result := ReadProcessMemory(GetCurrentProcess,
                    InterceptInfo.FunctionAddr,
                    @InterceptInfo.FunctCode[0], InterceptInfo.FunctCodeSize, Tmp);
 if not(Result) then exit;
 // Подготовка буфера с командой JMP на функцию - перехватчик
 JMP_Rel := DWORD(HookFunct) - (DWORD(InterceptInfo.FunctionAddr) + 5);
 InterceptInfo.HookJMP[0] := $0E9;
 CopyMemory(@InterceptInfo.HookJMP[1], @JMP_Rel, 4);
 // Копирование кода функции в буфер руткита
 CopyMemory(@InterceptInfo.HookBuf[0], @InterceptInfo.FunctCode[0], InterceptInfo.FunctCodeSize);
 // Подготовка буфера с командой JMP на продолжение перехватываемой функции
 JMP_Rel := (DWORD(InterceptInfo.FunctionAddr) + InterceptInfo.FunctCodeSize + 5) -
            (DWORD(@InterceptInfo.HookBuf[0])+InterceptInfo.FunctCodeSize+5+5);
 InterceptInfo.HookBuf[InterceptInfo.FunctCodeSize] := $0E9;
 CopyMemory(@InterceptInfo.HookBuf[InterceptInfo.FunctCodeSize+1], @JMP_Rel, 4);
 VirtualProtect(@InterceptInfo.HookBuf[0], InterceptInfo.FunctCodeSize+5, PAGE_EXECUTE_READWRITE, Tmp);
 // Установка перехватчика
 Result := SetHookCode(InterceptInfo, true);
end;


type
 TMessageBoxA = function (hWnd: HWND; lpText, lpCaption: PAnsiChar; uType: UINT): Integer; stdcall;
// Перехватчик MessageBoxA
function myMessageBoxA(hWnd: HWND; lpText, lpCaption: PAnsiChar; uType: UINT): Integer; stdcall;
begin
 // 2. Вызываем функцию
 Result := TMessageBoxA(@MessageBoxInterceptInfo.HookBuf[0])(hWnd, lpText, PChar(String(lpCaption)+'(перехвачена !)'), uType);
end;


begin
 MessageBoxA(0, 'Message1', 'Rootkit', 0);
 // Перехват MessageBoxA
 InterceptFunctionEx('user32.dll','MessageBoxA',
                     MessageBoxInterceptInfo, @myMessageBoxA);

 MessageBoxA(0, 'Message2', 'Rootkit', 0);
// HookHandle      := SetWindowsHookEx(WH_CBT, @KeyHook, HInstance, 0);
end.

