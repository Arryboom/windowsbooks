library rootkit1;
uses
  Windows,
  SysUtils,
  Classes,
  TlHelp32;

{$R *.res}
const
 IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT = 13; // Delay Load Import Descriptors
type
  TImageImportDescriptor = packed record  // (В C++ это IMAGE_IMPORT_DESCRIPTOR)
    OriginalFirstThunk : DWORD; // Ранее это поле называлось Characteristics; в целях сохранения
    TimeDateStamp      : DWORD; // 0, если импортирование осуществляется без привязки (binding - см. далее)
                                // При импортировании с привязкой содержит отметку времени файла, из которого идет импорт
    ForwarderChain     : DWORD; //
    Name               : DWORD; // Адрес ASCIIZ-строки с именем файла, из которого импортируем функции
    FirstThunk         : DWORD; // Виртуальный адрес подтаблицы импортируемых символов
  end;
  PImageImportDescriptor=^TImageImportDescriptor;

  // Таблица отложенного импорта (В C++ ImgDelayDescr в include\delayimp.h)
  TImgDelayDescr = packed record
    grAttrs      : DWORD; // Атрибуты (тип адресации: 0 - RVA, 1 - VA)
    rvaDLLName   : DWORD; // RVA имени DLL
    rvaHmod      : DWORD; // handle библиотеки (заполняется загрузчиком)
    rvaIAT       : DWORD; // Таблица адресов функций, последняя ячейка содержит 0
    rvaINT       : DWORD; // Таблица указателе на имена функций, последняя ячейка содержит 0
    rvaBoundIAT  : DWORD; // DWORD of the optional bound IAT
    rvaUnloadIAT : DWORD; // DWORD of optional copy of original IAT
    dwTimeStamp  : DWORD; // 0 if not bound, date/time stamp of DLL bound to (Old BIND)
  end;
  PImgDelayDescr = ^TImgDelayDescr;

  TMessageBoxA = function (hWnd: HWND; lpText, lpCaption: PAnsiChar; uType: UINT): Integer; stdcall;

function ImageDirectoryEntryToData(Base: Pointer; MappedAsImage: ByteBool;
  DirectoryEntry: Word; var Size: DWORD): Pointer; stdcall;
    external 'imagehlp.dll' name 'ImageDirectoryEntryToData';

var
 OldMessageBoxA : TMessageBoxA;

// Замена в IAT модуля AModule адреса OldFunct на NewFunct
function ReplaceIATEntry(AModule: hModule; ALibName : string; OldFunct, NewFunct: Pointer) : boolean;
var
  IAT_Size            : ULONG;                  // Размер IAT
  ImportDescriptorPtr : PImageImportDescriptor; // Указатель на IAT
  LibImportDescriptor : PImageImportDescriptor; // Указатель на запись IAT заданнйо DLL
  ThunkPtr            : LPDWORD;
  OldProtect, Tmp     : dword;
begin
 Result := false;
 // 1. Поиск IAT
 ImportDescriptorPtr := ImageDirectoryEntryToData(Pointer(AModule), TRUE,
    IMAGE_DIRECTORY_ENTRY_IMPORT, IAT_Size);
 // IAT не найдена - дальнейшее продолжение анализа невозможно
 if ImportDescriptorPtr = nil then exit;
 LibImportDescriptor := nil;
 // 2. Поиск секции импорта из DLL с именем ALibName
 while ImportDescriptorPtr.Name <> 0 do begin
  if (lstrcmpiA(PChar(AModule + ImportDescriptorPtr.Name), PChar(ALibName)) = 0) then begin
   LibImportDescriptor := ImportDescriptorPtr;
   // 3. Поиск адреса перехватываемой функции в таблице
   ThunkPtr := LPDWORD(AModule + LibImportDescriptor.FirstThunk);
   while ThunkPtr^ <> 0 do begin
    // Адрес найден ? Если да, то выполним его замену на заданный
    if (pointer(ThunkPtr^) = OldFunct) then begin
     // Настройка защиты - разрешим запись в эту страницу
     VirtualProtect(ThunkPtr, 4, PAGE_READWRITE, OldProtect);
     // Запись
     WriteProcessMemory(GetCurrentProcess, ThunkPtr, @NewFunct, 4, Tmp);
     // Восстановление атрибутов защиты
     VirtualProtect(ThunkPtr, 4, OldProtect, Tmp);
     Result := true;
    end;
    Inc(ThunkPtr);
   end;
  end;
  Inc(ImportDescriptorPtr);
 end;
end;

// Замена в DIT модуля AModule адреса OldFunct на NewFunct
function ReplaceDITEntry(AModule: hModule; ALibName : string; OldFunct, NewFunct: Pointer) : boolean;
var
  DIT_Size            : ULONG;          // Размер DIT
  ImgDelayDescr       : PImgDelayDescr; // Указатель на DIT
  LibImgDelayDescr    : PImgDelayDescr; // Указатель на запись DIT заданной DLL
  ThunkPtr            : LPDWORD;
  OldProtect, Tmp     : dword;
begin
 Result := false;
 // 1. Поиск DIT
 ImgDelayDescr := ImageDirectoryEntryToData(Pointer(AModule), TRUE,
    IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT, DIT_Size);
 // DIT не найдена - дальнейшее продолжение анализа невозможно
 if ImgDelayDescr = nil then exit;
 LibImgDelayDescr := nil;
 // 2. Поиск секции Delay Import из DLL с именем ALibName
 while ImgDelayDescr.rvaDLLName <> 0 do begin
  if (lstrcmpiA(PChar(AModule + ImgDelayDescr.rvaDLLName), PChar(ALibName)) = 0) then begin
   LibImgDelayDescr := ImgDelayDescr;
   // 3. Поиск адреса перехватываемой функции в таблице
   ThunkPtr := LPDWORD(AModule + LibImgDelayDescr.rvaIAT);
   while ThunkPtr^ <> 0 do begin
    // Адрес найден ? Если да, то выполним его замену на заданный
    if (pointer(ThunkPtr^) = OldFunct) then begin
     // Настройка защиты - разрешим запись в эту страницу
     VirtualProtect(ThunkPtr, 4, PAGE_READWRITE, OldProtect);
     // Запись
     WriteProcessMemory(GetCurrentProcess, ThunkPtr, @NewFunct, 4, Tmp);
     // Восстановление атрибутов защиты
     VirtualProtect(ThunkPtr, 4, OldProtect, Tmp);
     Result := true;
    end;
    Inc(ThunkPtr);
   end;
  end;
  Inc(ImgDelayDescr);
 end;
end;

function InterceptFunction(ALibName : string; OldFunct, NewFunct: Pointer) : boolean;
var
  hSnapshot : THandle;
  me32      : TModuleEntry32;
begin
 Result := false;
 // Создание "снимка" модулей текущего процесса
 hSnapshot := CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, GetCurrentProcessId);
 if hSnapshot = INVALID_HANDLE_VALUE then
  exit;
 me32.dwSize := SizeOf(TModuleEntry32);
 if (Module32First(hSnapshot, me32)) then
  repeat
   // Модификация таблицы импорта
   ReplaceIATEntry(me32.hModule, ALibName, OldFunct, NewFunct);
   // Модификация таблицы отложенного импорта
   ReplaceDITEntry(me32.hModule, ALibName, OldFunct, NewFunct);
  until not(Module32Next(hSnapshot, me32));
 CloseHandle(hSnapshot);
 Result := true;
end;

// Перехватчик
function myMessageBoxA(hWnd: HWND; lpText, lpCaption: PAnsiChar; uType: UINT): Integer; stdcall;
begin
 Result := OldMessageBoxA(hWnd, lpText, PChar(String(lpCaption)+'(перехвачена !)'), uType);
end;

function myGetProcAddress(hModule: HMODULE; lpProcName: LPCSTR): FARPROC; stdcall;
begin

end;

function myLoadLibrary(lpLibFileName: PChar): HMODULE; stdcall;
begin

end;

begin
 MessageBoxA(0, 'Message1', 'Rootkit', 0);
 @OldMessageBoxA := GetProcAddress(GetModuleHandle('user32.dll'), 'MessageBoxA');
 InterceptFunction('user32.dll',
                   @OldMessageBoxA,
                   @myMessageBoxA);
 MessageBoxA(0, 'Message2', 'Rootkit', 0);
end.

