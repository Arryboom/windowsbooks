unit Unit1;

interface

uses
  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
  Dialogs, StdCtrls;

type
  TForm1 = class(TForm)
    Memo1: TMemo;
    Button1: TButton;
    procedure Button1Click(Sender: TObject);
  private
    procedure HideLibrary;
    { Private declarations }
  public
    { Public declarations }
  end;

var
  Form1: TForm1;

implementation

{$R *.dfm}
const
 STATUS_SUCCESS = 0;
type
 NTStatus = DWORD;
 PROCESS_BASIC_INFORMATION = packed record
   ExitStatus: BOOL;
   PebBaseAddress: pointer;
   AffinityMask: PULONG;
   BasePriority: dword;
   UniqueProcessId: ULONG;
   InheritedFromUniqueProcessId: ULONG;
  end;
 PPROCESS_BASIC_INFORMATION = ^PROCESS_BASIC_INFORMATION;

 PEB_LDR_DATA = packed record
  Length      : DWORD;
  Initialized : BOOL;
  SsHandle    : pointer;
  InLoadOrderModuleList           : LIST_ENTRY; // Элементы LIST_ENTRY указателями
  InMemoryOrderModuleList         : LIST_ENTRY;
  InInitializationOrderModuleList : LIST_ENTRY;
 end;
 PPEB_LDR_DATA = ^PEB_LDR_DATA;

 // Структура, содержащая первые поля PEB
 PEB = packed record
  InheritedAddressSpace    : byte;    // +00h
  ReadImageFileExecOptions : byte;    // +01h
  BeingDebugged            : byte;    // +02h
  Spare                    : byte;    // +03h
  Mutant                   : pointer; // +04h
  ImageBaseAddress         : pointer; // +08h
  Ldr                      : PPEB_LDR_DATA; // +0Ch
 end;

 // Строка в формате UNICODE
 TUNICODE_STRING = packed record
  Length    :  word;    // Длина строки
  MaxLength :  word;    // Максимальная длина (размер выделенного буфера)
  StrData   :  lpwstr;  // Указатель на область памяти, хранящую строку
 end;

 // Структура LDR_MODULE
 LDR_MODULE = packed record
  InLoadOrderModuleList           : LIST_ENTRY; // Элементы LIST_ENTRY указателями
  InMemoryOrderModuleList         : LIST_ENTRY;
  InInitializationOrderModuleList : LIST_ENTRY;
  BaseAddress                     : Pointer; // Базовый адрес
  EntryPoint                      : Pointer; // Точка входа
  SizeOfImage                     : DWORD;   // Размер образа в памяти
  FullDllName                     : TUNICODE_STRING;
  BaseDllName                     : TUNICODE_STRING;
  Flags                           : DWORD;
  LoadCount                       : SHORT;   // Счетчик кол-ва загрузок
  TlsIndex                        : SHORT;
  HashTableEntry                  : LIST_ENTRY;
  TimeDateStamp                   : ULONG;
 end;

// Функция NtQueryInformationProcess - применяется
Function NtQueryInformationProcess(
                                ProcessHandle:THANDLE;
                                ProcessInformationClass:DWORD;
                                ProcessInformation:pointer;
                                ProcessInformationLength:ULONG;
                                ReturnLength: PULONG):NTSTATUS;stdcall;
                                external 'ntdll.dll';

Function RtlGetCurrentPeb:DWORD; stdcall;
                                 external 'ntdll.dll';

procedure TForm1.Button1Click(Sender: TObject);
begin
 HideLibrary;
end;

Procedure TForm1.HideLibrary;
var
 PI : PROCESS_BASIC_INFORMATION;
 FirstModule, TekModule : LDR_MODULE;
 PEB1 : DWORD;
begin
 // Запрос информации о текущем процессе (нас интересует только адрес PEB)
 if NtQueryInformationProcess(GetCurrentProcess,
                              0, // 0 - ProcessBasicInformation
                              @PI,
                              SizeOf(PROCESS_BASIC_INFORMATION),
                              nil) <> STATUS_SUCCESS then exit;
 // Получение адреса PEB чтением fs:[30h]
 asm
   mov eax, fs:[30h]
   mov PEB1, eax
 end;
 Memo1.Lines.Add('PEB (NtQueryInformationProcess) = '+IntToHex(DWORD(PI.PebBaseAddress), 6));
 Memo1.Lines.Add('PEB (fs:[30h]) = '+IntToHex(PEB1, 6));
 Memo1.Lines.Add('PEB (RtlGetCurrentPeb) = '+IntToHex(RtlGetCurrentPeb, 6));

 // Получаем LIST_ENTRY первого модуля в списке
 FirstModule := LDR_MODULE(pointer(PEB(PI.PebBaseAddress^).Ldr.InLoadOrderModuleList.Flink)^);
 TekModule   := FirstModule;
 repeat
  // Вывод данных в протокол
  Memo1.Lines.Add(TekModule.FullDllName.StrData+
                  ' BaseAddress='+IntToHex(dword(TekModule.BaseAddress), 6));
  // Маскировка - условием маскировки является наличие "ntdll" в имени библиотеки
  if Pos('ntdll', LowerCase(TekModule.FullDllName.StrData)) > 0 then begin
   // Переключаем ссылки в списке  InLoadOrderModuleList
   LDR_MODULE(pointer(TekModule.InLoadOrderModuleList.Flink)^).InLoadOrderModuleList.Blink := TekModule.InLoadOrderModuleList.Blink;
   LDR_MODULE(pointer(TekModule.InLoadOrderModuleList.Blink)^).InLoadOrderModuleList.Flink := TekModule.InLoadOrderModuleList.Flink;
{   // Переключаем ссылки в списке  InMemoryOrderModuleList
   LDR_MODULE(pointer(TekModule.InMemoryOrderModuleList.Flink)^).InMemoryOrderModuleList.Blink := TekModule.InMemoryOrderModuleList.Blink;
   LDR_MODULE(pointer(TekModule.InMemoryOrderModuleList.Blink)^).InMemoryOrderModuleList.Flink := TekModule.InMemoryOrderModuleList.Flink;
   // Переключаем ссылки в списке  InInitializationOrderModuleList
   LDR_MODULE(pointer(TekModule.InInitializationOrderModuleList.Flink)^).InInitializationOrderModuleList.Blink := TekModule.InInitializationOrderModuleList.Blink;
   LDR_MODULE(pointer(TekModule.InInitializationOrderModuleList.Blink)^).InInitializationOrderModuleList.Flink := TekModule.InInitializationOrderModuleList.Flink;}
  end;
  // Переход на следующий элемент
  TekModule := LDR_MODULE(pointer(TekModule.InLoadOrderModuleList.Flink)^);
  // Выхода из цикла после обхода всего списка и возврата к элементу, с которого начали обход
 until (TekModule.BaseAddress = FirstModule.BaseAddress);
end;

end.
