// Драйвер-фильтр для перехвата клавиатурных событий
// (С) Зайцев Олег, 2006
#include <StdAfx.h>
#include <ntddk.h>
#include <ntdef.h>
#include <kd4.h>
#include <ntddkbd.h>

// Указатель на DeviceObject->DeviceExtension
PDEVICE_EXTENSION pGlobalDevExt;


NTSTATUS OnReadCompletion(IN PDEVICE_OBJECT pDeviceObject, IN PIRP Irp, IN PVOID Context)
{
	// Если Status = STATUS_SUCCESS, то в буфере IRP есть данные о нажатиях клавиш
	if(Irp->IoStatus.Status == STATUS_SUCCESS)
	{
		// Указатель на буфер (эта структура декларирована в ntddkbd.h
		PKEYBOARD_INPUT_DATA KeyData = (PKEYBOARD_INPUT_DATA)Irp->AssociatedIrp.SystemBuffer;
		// Кол-во данных о нажатиях в буфере
		int KeyDataCount = Irp->IoStatus.Information / sizeof(KEYBOARD_INPUT_DATA);
        // Вывод информации из буфера через DbgPrint 
		for(int i = 0; i < KeyDataCount; i++)
		{
			DbgPrint("ScanCode: %x ", KeyData[i].MakeCode);
            // Флаги
			switch (KeyData[i].Flags) {
			 case KEY_MAKE:
				 DbgPrint("%s ","Key Down (KEY_MAKE)");
				 break;
			 case KEY_BREAK:
				 DbgPrint("%s ","Key Up (KEY_BREAK)");
				 break;
			 case KEY_E0:
				 DbgPrint("%s ","(KEY_E0)");
				 break;
			 case KEY_E1:
				 DbgPrint("%s ","(KEY_E1)");
				 break;
			}			
			DbgPrint("\n");
		}		
	}

	// Постановка IRP в очередь (если необходимо)
	if(Irp->PendingReturned)
		IoMarkIrpPending(Irp);

	return Irp->IoStatus.Status;
}

// Обработчик IRP_MJ_READ
NTSTATUS DriverDispatchRead(IN PDEVICE_OBJECT DeviceObject,  IN PIRP Irp)
{
    PIO_STACK_LOCATION currentIrpStack = IoGetCurrentIrpStackLocation(Irp);
	PIO_STACK_LOCATION nextIrpStack    = IoGetNextIrpStackLocation(Irp);
    *nextIrpStack = *currentIrpStack;

	// Встановили в IRP нашу callback-функцию завершения
	IoSetCompletionRoutine(Irp, OnReadCompletion, DeviceObject, TRUE, TRUE, TRUE);
    // Передаем IRP драйверу
    return IoCallDriver(pGlobalDevExt->KbdDevice, Irp);	

}

// Ретранслятор
NTSTATUS DriverDispatchGeneral(IN PDEVICE_OBJECT DeviceObject,  IN PIRP Irp)
{
	// Пропускаем все IRP без обработки 
	IoSkipCurrentIrpStackLocation(Irp);
    return IoCallDriver(pGlobalDevExt->KbdDevice, Irp);
}

// Установка фильтра
NTSTATUS InstallKeyboardFilter(IN PDRIVER_OBJECT DriverObject)
{
    UNICODE_STRING          ntUnicodeString;
    NTSTATUS                ntStatus;
    PDEVICE_OBJECT          DeviceObject        = NULL;

    // Устанавливаем фильтр на \Device\KeyboardClass0
    RtlInitUnicodeString( &ntUnicodeString, L"\\Device\\KeyboardClass0" );
    ntStatus = IoCreateDevice( DriverObject,
                 0,
                 NULL,
                 FILE_DEVICE_KEYBOARD,
                 0,
                 FALSE,
                 &DeviceObject );

    if( !NT_SUCCESS(ntStatus) ) {
        DbgPrint("InstallKeyboardFilter: IoCreateDevice error");
        return ntStatus;
    }
    //
    // Установка флага DO_BUFFERED_IO    
    DeviceObject->Flags |= DO_BUFFERED_IO;
    //
    // Подключение нашего фильтра
    ntStatus = IoAttachDevice( DeviceObject, &ntUnicodeString, &pGlobalDevExt->KbdDevice );
    if( !NT_SUCCESS(ntStatus) ) {
        DbgPrint("InstallKeyboardFilter: error, IoAttachDevice error");
        IoDeleteDevice( DeviceObject );    
        return ntStatus;
    }
    pGlobalDevExt->KbdFilterDevice = DeviceObject;

    return STATUS_SUCCESS;
}

// Функция, отвечающая за выгрузку драйвера
VOID DriverUnload (PDRIVER_OBJECT DriverObject)
{
    UNICODE_STRING usSymbolicLinkName;
    
    // Удаляем ссылку
    RtlInitUnicodeString(&usSymbolicLinkName, L"\\DosDevices\\KD4");
    IoDeleteSymbolicLink(&usSymbolicLinkName);
    // Отключаем фильтр
    IoDetachDevice(pGlobalDevExt->KbdDevice);
	// Удаляем созданные нами устройства
    IoDeleteDevice(pGlobalDevExt->KbdFilterDevice);    
    IoDeleteDevice(DriverObject->DeviceObject);
 }

// Точка входа драйвера
NTSTATUS DriverEntry(IN PDRIVER_OBJECT  DriverObject,
                     IN PUNICODE_STRING RegistryPath )
{
    PDEVICE_OBJECT         DeviceObject        = NULL;
    NTSTATUS               ntStatus;
    UNICODE_STRING         usDeviceNameUnicodeString;
    UNICODE_STRING         usDeviceLinkUnicodeString;

    
    // Подготовка Unicode строк
    RtlInitUnicodeString (&usDeviceNameUnicodeString,
                          L"\\Device\\KD4");
    RtlInitUnicodeString (&usDeviceLinkUnicodeString,
                          L"\\DosDevices\\KD4" );
    // Создание устройства
    ntStatus = IoCreateDevice (DriverObject,
                               sizeof(DEVICE_EXTENSION),
                               &usDeviceNameUnicodeString,
                               FILE_DEVICE_UNKNOWN,
                               0,
                               TRUE,
                               &DeviceObject);

    if (!NT_SUCCESS(ntStatus)) {
        return ntStatus;
    }
	// Запомним указатель на DeviceObject->DeviceExtension для его применения в обработчиках
    pGlobalDevExt = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    
    // Создание символьной ссылки     
    ntStatus = IoCreateSymbolicLink (&usDeviceLinkUnicodeString,
                                     &usDeviceNameUnicodeString );
    if (!NT_SUCCESS(ntStatus)) {
		DbgPrint("DriverEntry: IoCreateSymbolicLink error\n");
        IoDeleteDevice(DeviceObject);
        return ntStatus;
    }
    
    // Создание и подключение фильтра    
    ntStatus = InstallKeyboardFilter( DriverObject );
    if(!NT_SUCCESS(ntStatus)) {
      IoDeleteDevice (DeviceObject);  
      return ntStatus;
    }

    // Подключение обработчика-ретранслятора ко всем функциям
	for(int i = 0; i < IRP_MJ_MAXIMUM_FUNCTION; i++)
		DriverObject->MajorFunction[i] = DriverDispatchGeneral;
	// Отдельный обработчик - для IRP_MJ_READ
	DriverObject->MajorFunction[IRP_MJ_READ] = DriverDispatchRead;
	DriverObject->DriverUnload = DriverUnload;
        
    return ntStatus;
}
