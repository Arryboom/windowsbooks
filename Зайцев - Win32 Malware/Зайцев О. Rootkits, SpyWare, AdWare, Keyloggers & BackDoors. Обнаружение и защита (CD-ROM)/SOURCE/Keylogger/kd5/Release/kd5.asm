; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\kd5.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BJ@HGBJNICO@KBD?5Code?5?$DN?5?$CFd?0?5hWnd?5?$DN?5?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DB@GDMPNLBP@?$DO?$DO?5cmp?5KeServiceDescriptorTable?$FL@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DM@CGACKBEK@?$DO?$DO?5lea?5ecx?0?5KeServiceDescriptorT@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@BOCCBFKI@KeServiceDescriptorTableShadow?5?$DN@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DJ@COADGJJP@KeServiceDescriptorTableShadow?9?$DO@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DJ@MOCCDNF@KeServiceDescriptorTableShadow?9?$DO@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09EFACLNKP@Set?5Hook?3?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@KPKFPIDH@OldPeekMessage?5?$DN?5?$CFX?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1CK@KCDJMENH@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAK?$AAD?$AA5?$AAL?$AAi?$AAn?$AAk?$AA2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@NHKJCBKH@Device?5Open?5?$CB?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@BNJDKDLD@IoControlCode?5?$DN?5?$CFx?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BI@MLGDGAJJ@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAK?$AAD?$AA5?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@JFBALODB@IoCreateDevice?5error?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CJ@JPLNHOOH@DriverEntry?3?5IoCreateSymbolicLin@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _IsEqualGUID@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MyPeekMessage@@YGHPAUtagMSG@@KKKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindShadowTable@@YGPAU_SERVICE_DESCRIPTOR_TABLE@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetKiSTShadowHook@@YGJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DriverUnload@@YGXPAU_DRIVER_OBJECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DispatchCreateCloseControl@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DispatchControl@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DriverEntry@@YGJPAU_DRIVER_OBJECT@@PAU_UNICODE_STRING@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?OldPeekMessage@@3P6GHPAUtagMSG@@KKKK@ZA	; OldPeekMessage
PUBLIC	?HookInstalled@@3HA				; HookInstalled
_BSS	SEGMENT
?OldPeekMessage@@3P6GHPAUtagMSG@@KKKK@ZA DD 01H DUP (?)	; OldPeekMessage
?HookInstalled@@3HA DD 01H DUP (?)			; HookInstalled
_BSS	ENDS
PUBLIC	?MyPeekMessage@@YGHPAUtagMSG@@KKKK@Z		; MyPeekMessage
PUBLIC	??_C@_0BJ@HGBJNICO@KBD?5Code?5?$DN?5?$CFd?0?5hWnd?5?$DN?5?$CFd?$AA@ ; `string'
EXTRN	_DbgPrint:NEAR
;	COMDAT ??_C@_0BJ@HGBJNICO@KBD?5Code?5?$DN?5?$CFd?0?5hWnd?5?$DN?5?$CFd?$AA@
; File e:\delphi5\delphi7\projects\bhv\kd5\kd5.cpp
CONST	SEGMENT
??_C@_0BJ@HGBJNICO@KBD?5Code?5?$DN?5?$CFd?0?5hWnd?5?$DN?5?$CFd?$AA@ DB 'K'
	DB	'BD Code = %d, hWnd = %d', 00H		; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?MyPeekMessage@@YGHPAUtagMSG@@KKKK@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_hWnd$ = 12						; size = 4
_wMsgFilterMin$ = 16					; size = 4
_wMsgFilterMax$ = 20					; size = 4
_wRemoveMsg$ = 24					; size = 4
?MyPeekMessage@@YGHPAUtagMSG@@KKKK@Z PROC NEAR		; MyPeekMessage, COMDAT

; 34   :  BOOL Res = OldPeekMessage(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg);

	mov	eax, DWORD PTR _wRemoveMsg$[esp-4]
	mov	ecx, DWORD PTR _wMsgFilterMax$[esp-4]
	mov	edx, DWORD PTR _wMsgFilterMin$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR _lpMsg$[esp+4]
	push	eax
	mov	eax, DWORD PTR _hWnd$[esp+8]
	push	ecx
	push	edx
	push	eax
	push	edi
	call	DWORD PTR ?OldPeekMessage@@3P6GHPAUtagMSG@@KKKK@ZA ; OldPeekMessage
	mov	esi, eax

; 35   :  // Сообщение WM_KEYDOWN имеет код 0x0100
; 36   :  if (Res && (lpMsg->message == 0x0100))

	test	esi, esi
	je	SHORT $L10091
	cmp	DWORD PTR [edi+4], 256			; 00000100H
	jne	SHORT $L10091

; 37   : 	 zDbgPrint("KBD Code = %d, hWnd = %d", lpMsg->lParam, lpMsg->hwnd);

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [edi+12]
	push	ecx
	push	edx
	push	OFFSET FLAT:??_C@_0BJ@HGBJNICO@KBD?5Code?5?$DN?5?$CFd?0?5hWnd?5?$DN?5?$CFd?$AA@
	call	_DbgPrint
	add	esp, 12					; 0000000cH
$L10091:
	pop	edi

; 38   :  return Res;

	mov	eax, esi
	pop	esi

; 39   : }

	ret	20					; 00000014H
?MyPeekMessage@@YGHPAUtagMSG@@KKKK@Z ENDP		; MyPeekMessage
_TEXT	ENDS
PUBLIC	?FindShadowTable@@YGPAU_SERVICE_DESCRIPTOR_TABLE@@XZ ; FindShadowTable
PUBLIC	??_C@_0DB@GDMPNLBP@?$DO?$DO?5cmp?5KeServiceDescriptorTable?$FL@ ; `string'
PUBLIC	??_C@_0DM@CGACKBEK@?$DO?$DO?5lea?5ecx?0?5KeServiceDescriptorT@ ; `string'
EXTRN	_KeServiceDescriptorTable:DWORD
EXTRN	__imp__KeAddSystemServiceTable@20:NEAR
;	COMDAT ??_C@_0DB@GDMPNLBP@?$DO?$DO?5cmp?5KeServiceDescriptorTable?$FL@
CONST	SEGMENT
??_C@_0DB@GDMPNLBP@?$DO?$DO?5cmp?5KeServiceDescriptorTable?$FL@ DB '>> cm'
	DB	'p KeServiceDescriptorTable[eax] found at %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@CGACKBEK@?$DO?$DO?5lea?5ecx?0?5KeServiceDescriptorT@
CONST	SEGMENT
??_C@_0DM@CGACKBEK@?$DO?$DO?5lea?5ecx?0?5KeServiceDescriptorT@ DB '>> lea'
	DB	' ecx, KeServiceDescriptorTableShadow[eax] found at %d', 00H ; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?FindShadowTable@@YGPAU_SERVICE_DESCRIPTOR_TABLE@@XZ
_TEXT	SEGMENT
?FindShadowTable@@YGPAU_SERVICE_DESCRIPTOR_TABLE@@XZ PROC NEAR ; FindShadowTable, COMDAT

; 43   :   // При поиске пропускаем первые 5 байт (mov edi, edi; push ebp; mov ebp, es)
; 44   :   PBYTE  ScanPtr = (BYTE*) KeAddSystemServiceTable + 5, CmpKiSTPtr = NULL;
; 45   :   // Поиск команды 83 B8 xx xx xx xx 00, где xx xx xx xx = KeServiceDescriptorTable
; 46   :   for (int i=0; i < 30; i++)

	mov	ecx, DWORD PTR _KeServiceDescriptorTable
	push	esi
	mov	esi, DWORD PTR __imp__KeAddSystemServiceTable@20
	add	esi, 5
	xor	eax, eax
	mov	dl, 184					; 000000b8H
$L9949:

; 47   :   {
; 48   : 	  if (*(ScanPtr - 2) == 0x83 && *(ScanPtr - 1) == 0xB8 &&
; 49   : 		  *(PDWORD)ScanPtr == (DWORD)KeServiceDescriptorTable) {

	cmp	BYTE PTR [esi-2], 131			; 00000083H
	jne	SHORT $L9954
	cmp	BYTE PTR [esi-1], dl
	jne	SHORT $L9954
	cmp	DWORD PTR [esi], ecx
	je	SHORT $L10096
$L9954:

; 52   : 			  break;
; 53   : 		  }
; 54   : 	  ScanPtr++;   

	inc	esi
	inc	eax
	cmp	eax, 30					; 0000001eH
	jl	SHORT $L9949

; 58   : 	  return 0;

	xor	eax, eax
	pop	esi

; 70   : }

	ret	0
$L10096:

; 50   : 			  zDbgPrint(">> cmp KeServiceDescriptorTable[eax] found at %d", i); 

	push	eax
	push	OFFSET FLAT:??_C@_0DB@GDMPNLBP@?$DO?$DO?5cmp?5KeServiceDescriptorTable?$FL@
	call	_DbgPrint

; 51   : 			  CmpKiSTPtr = (ScanPtr - 2);

	lea	eax, DWORD PTR [esi-2]
	add	esp, 8

; 55   :   }
; 56   :   // Команда "cmp KeServiceDescriptorTable[eax], 0" не обнаружена ?
; 57   :   if (!CmpKiSTPtr)

	test	eax, eax
	jne	SHORT $L9956
	pop	esi

; 70   : }

	ret	0
$L9956:

; 59   :   // Пропускаем команду 
; 60   :   ScanPtr = CmpKiSTPtr + 9;

	lea	esi, DWORD PTR [eax+9]

; 61   :   for (int i=0; i < 16; i++) {

	xor	eax, eax
	mov	dl, 141					; 0000008dH
	mov	cl, 136					; 00000088H
	npad	2
$L9958:

; 62   : 	  if (*(ScanPtr - 2) == 0x8D && *(ScanPtr - 1) == 0x88) {

	cmp	BYTE PTR [esi-2], dl
	jne	SHORT $L9961
	cmp	BYTE PTR [esi-1], cl
	je	SHORT $L10097
$L9961:

; 65   : 			  break;
; 66   : 		  }
; 67   : 	  ScanPtr++;   

	inc	esi
	inc	eax
	cmp	eax, 16					; 00000010H
	jl	SHORT $L9958

; 68   :   }
; 69   :   return NULL;

	xor	eax, eax
	pop	esi

; 70   : }

	ret	0
$L10097:

; 63   : 			  zDbgPrint(">> lea ecx, KeServiceDescriptorTableShadow[eax] found at %d", i); 

	push	eax
	push	OFFSET FLAT:??_C@_0DM@CGACKBEK@?$DO?$DO?5lea?5ecx?0?5KeServiceDescriptorT@
	call	_DbgPrint

; 64   : 			  return (PSERVICE_DESCRIPTOR_TABLE)*(PDWORD)ScanPtr;

	mov	eax, DWORD PTR [esi]
	add	esp, 8
	pop	esi

; 70   : }

	ret	0
?FindShadowTable@@YGPAU_SERVICE_DESCRIPTOR_TABLE@@XZ ENDP ; FindShadowTable
_TEXT	ENDS
PUBLIC	?SetKiSTShadowHook@@YGJH@Z			; SetKiSTShadowHook
PUBLIC	??_C@_0CE@BOCCBFKI@KeServiceDescriptorTableShadow?5?$DN@ ; `string'
PUBLIC	??_C@_0DJ@COADGJJP@KeServiceDescriptorTableShadow?9?$DO@ ; `string'
PUBLIC	??_C@_0DJ@MOCCDNF@KeServiceDescriptorTableShadow?9?$DO@ ; `string'
PUBLIC	??_C@_09EFACLNKP@Set?5Hook?3?$AA@		; `string'
PUBLIC	??_C@_0BE@KPKFPIDH@OldPeekMessage?5?$DN?5?$CFX?$AA@ ; `string'
EXTRN	_NtBuildNumber:DWORD
EXTRN	__imp_@KfLowerIrql@4:NEAR
EXTRN	__imp__KeRaiseIrqlToDpcLevel@0:NEAR
;	COMDAT ??_C@_0CE@BOCCBFKI@KeServiceDescriptorTableShadow?5?$DN@
CONST	SEGMENT
??_C@_0CE@BOCCBFKI@KeServiceDescriptorTableShadow?5?$DN@ DB 'KeServiceDes'
	DB	'criptorTableShadow = %X', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@COADGJJP@KeServiceDescriptorTableShadow?9?$DO@
CONST	SEGMENT
??_C@_0DJ@COADGJJP@KeServiceDescriptorTableShadow?9?$DO@ DB 'KeServiceDes'
	DB	'criptorTableShadow->win32k.ServiceLimit = %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@MOCCDNF@KeServiceDescriptorTableShadow?9?$DO@
CONST	SEGMENT
??_C@_0DJ@MOCCDNF@KeServiceDescriptorTableShadow?9?$DO@ DB 'KeServiceDesc'
	DB	'riptorTableShadow->win32k.ServiceTable = %X', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09EFACLNKP@Set?5Hook?3?$AA@
CONST	SEGMENT
??_C@_09EFACLNKP@Set?5Hook?3?$AA@ DB 'Set Hook:', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KPKFPIDH@OldPeekMessage?5?$DN?5?$CFX?$AA@
CONST	SEGMENT
??_C@_0BE@KPKFPIDH@OldPeekMessage?5?$DN?5?$CFX?$AA@ DB 'OldPeekMessage = '
	DB	'%X', 00H					; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?SetKiSTShadowHook@@YGJH@Z
_TEXT	SEGMENT
_OldCR0$ = 8						; size = 4
_ASetHook$ = 8						; size = 4
?SetKiSTShadowHook@@YGJH@Z PROC NEAR			; SetKiSTShadowHook, COMDAT

; 75   : 	// Защита от повторной установки/удаления перехватчика
; 76   : 	if ((HookInstalled && ASetHook) || (!HookInstalled && !ASetHook)) 

	mov	eax, DWORD PTR ?HookInstalled@@3HA	; HookInstalled
	test	eax, eax
	push	edi
	mov	edi, DWORD PTR _ASetHook$[esp]
	je	SHORT $L10104
	test	edi, edi
	jne	SHORT $L9969
	jmp	SHORT $L9968
$L10104:
	test	edi, edi

; 77   : 		return STATUS_UNSUCCESSFUL;

	je	SHORT $L9969
$L9968:

; 78   : 	int PeekMessageCode = -1;
; 79   : 	switch (*NtBuildNumber) {

	mov	eax, DWORD PTR _NtBuildNumber
	cmp	WORD PTR [eax], 2600			; 00000a28H

; 80   :    case  2195:  // Win 2k
; 81   : 	   break;
; 82   :    case 2600:   // Win XP
; 83   : 	   PeekMessageCode = 0x1DA;
; 84   : 	   break;
; 85   :    case 3790:  // W2K3
; 86   : 	   break;
; 87   : 	}
; 88   : 	// Для текущей операционной системы не удалось определить код функции
; 89   : 	if (PeekMessageCode == -1) 

	je	SHORT $L9980
$L9969:

; 90   : 		return STATUS_UNSUCCESSFUL;

	mov	eax, -1073741823			; c0000001H
	pop	edi

; 134  : }

	ret	4
$L9980:
	push	esi

; 91   : 
; 92   : 	// Поиск KeServiceDescriptorTableShadow
; 93   : 	PSERVICE_DESCRIPTOR_TABLE    KeServiceDescriptorTableShadow = FindShadowTable();

	call	?FindShadowTable@@YGPAU_SERVICE_DESCRIPTOR_TABLE@@XZ ; FindShadowTable
	mov	esi, eax

; 94   : 	zDbgPrint("KeServiceDescriptorTableShadow = %X", KeServiceDescriptorTableShadow );

	push	esi
	push	OFFSET FLAT:??_C@_0CE@BOCCBFKI@KeServiceDescriptorTableShadow?5?$DN@
	call	_DbgPrint
	add	esp, 8

; 95   : 	// Если адрес таблицы KeServiceDescriptorTableShadow определить не удается, то
; 96   : 	// далее продолжать нет смысла
; 97   : 	if (!KeServiceDescriptorTableShadow) 

	test	esi, esi
	jne	SHORT $L9984
	pop	esi

; 98   :      return STATUS_UNSUCCESSFUL;

	mov	eax, -1073741823			; c0000001H
	pop	edi

; 134  : }

	ret	4
$L9984:

; 99   : 	// Вывод полей для отладки
; 100  : 	zDbgPrint("KeServiceDescriptorTableShadow->win32k.ServiceLimit = %d", KeServiceDescriptorTableShadow->win32k.ServiceLimit);

	mov	ecx, DWORD PTR [esi+24]
	push	ebx
	push	ecx
	push	OFFSET FLAT:??_C@_0DJ@COADGJJP@KeServiceDescriptorTableShadow?9?$DO@
	call	_DbgPrint

; 101  : 	zDbgPrint("KeServiceDescriptorTableShadow->win32k.ServiceTable = %X", KeServiceDescriptorTableShadow->win32k.ServiceTable);

	mov	edx, DWORD PTR [esi+16]
	push	edx
	push	OFFSET FLAT:??_C@_0DJ@MOCCDNF@KeServiceDescriptorTableShadow?9?$DO@
	call	_DbgPrint
	add	esp, 16					; 00000010H

; 102  : 
; 103  : 	DWORD OldCR0;	  
; 104  : 	// Повышение приоритета
; 105  : 	KIRQL OldIRQL = KeRaiseIrqlToDpcLevel();			 

	call	DWORD PTR __imp__KeRaiseIrqlToDpcLevel@0
	mov	bl, al

; 106  : 
; 107  : 	// Сброс WP бита
; 108  : 	_asm {
; 109  : 		mov eax,CR0

	mov	eax, cr0

; 110  : 		mov OldCR0,eax

	mov	DWORD PTR _OldCR0$[esp+8], eax

; 111  : 		and eax,0xFFFEFFFF			

	and	eax, -65537				; fffeffffH

; 112  : 		mov cr0, eax

	mov	cr0, eax

; 113  : 	}
; 114  : 	// Перехват PeekMessage
; 115  : 	if (ASetHook) {

	test	edi, edi
	je	SHORT $L9990

; 116  : 		zDbgPrint("Set Hook:");

	push	OFFSET FLAT:??_C@_09EFACLNKP@Set?5Hook?3?$AA@
	call	_DbgPrint

; 117  : 		OldPeekMessage = (PPeekMessage)*KeServiceDescriptorTableShadow->win32k.ServiceTable[PeekMessageCode];

	mov	eax, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [eax+1896]

; 118  : 		zDbgPrint("OldPeekMessage = %X", OldPeekMessage);

	push	eax
	push	OFFSET FLAT:??_C@_0BE@KPKFPIDH@OldPeekMessage?5?$DN?5?$CFX?$AA@
	mov	DWORD PTR ?OldPeekMessage@@3P6GHPAUtagMSG@@KKKK@ZA, eax ; OldPeekMessage
	call	_DbgPrint

; 119  : 		KeServiceDescriptorTableShadow->win32k.ServiceTable[PeekMessageCode]   = (NTPROC)*MyPeekMessage;

	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [ecx+1896], OFFSET FLAT:?MyPeekMessage@@YGHPAUtagMSG@@KKKK@Z ; MyPeekMessage
	add	esp, 12					; 0000000cH

; 120  : 		HookInstalled = true;

	mov	DWORD PTR ?HookInstalled@@3HA, 1	; HookInstalled

; 121  : 	} 
; 122  : 	else {

	jmp	SHORT $L9995
$L9990:

; 123  : 		KeServiceDescriptorTableShadow->win32k.ServiceTable[PeekMessageCode]   = (NTPROC)*OldPeekMessage;

	mov	edx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR ?OldPeekMessage@@3P6GHPAUtagMSG@@KKKK@ZA ; OldPeekMessage
	mov	DWORD PTR [edx+1896], eax

; 124  : 		HookInstalled = false;

	mov	DWORD PTR ?HookInstalled@@3HA, 0	; HookInstalled
$L9995:

; 125  : 	}
; 126  : 
; 127  : 	// Восстановление WP бита
; 128  : 	_asm {
; 129  : 		mov eax,OldCR0

	mov	eax, DWORD PTR _OldCR0$[esp+8]

; 130  : 		mov cr0,eax

	mov	cr0, eax

; 131  : 	}
; 132  : 	// Восстановление приоритета
; 133  : 	KeLowerIrql(OldIRQL);

	mov	cl, bl
	call	DWORD PTR __imp_@KfLowerIrql@4
	pop	ebx
	pop	esi
	pop	edi

; 134  : }

	ret	4
?SetKiSTShadowHook@@YGJH@Z ENDP				; SetKiSTShadowHook
_TEXT	ENDS
PUBLIC	?DriverUnload@@YGXPAU_DRIVER_OBJECT@@@Z		; DriverUnload
PUBLIC	??_C@_1CK@KCDJMENH@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAK?$AAD?$AA5?$AAL?$AAi?$AAn?$AAk?$AA2@ ; `string'
EXTRN	__imp__IoDeleteDevice@4:NEAR
EXTRN	__imp__IoDeleteSymbolicLink@4:NEAR
EXTRN	__imp__RtlInitUnicodeString@8:NEAR
;	COMDAT ??_C@_1CK@KCDJMENH@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAK?$AAD?$AA5?$AAL?$AAi?$AAn?$AAk?$AA2@
CONST	SEGMENT
??_C@_1CK@KCDJMENH@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAK?$AAD?$AA5?$AAL?$AAi?$AAn?$AAk?$AA2@ DB '\'
	DB	00H, 'D', 00H, 'o', 00H, 's', 00H, 'D', 00H, 'e', 00H, 'v', 00H
	DB	'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'K', 00H, 'D'
	DB	00H, '5', 00H, 'L', 00H, 'i', 00H, 'n', 00H, 'k', 00H, '2', 00H
	DB	00H, 00H					; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?DriverUnload@@YGXPAU_DRIVER_OBJECT@@@Z
_TEXT	SEGMENT
_OldCR0$10123 = -12					; size = 4
_usSymbolicLinkName$ = -8				; size = 8
_DriverObject$ = 8					; size = 4
?DriverUnload@@YGXPAU_DRIVER_OBJECT@@@Z PROC NEAR	; DriverUnload, COMDAT

; 139  : {

	sub	esp, 12					; 0000000cH

; 140  :     UNICODE_STRING usSymbolicLinkName; 
; 141  :     // Удаляем ссылку
; 142  :     RtlInitUnicodeString(&usSymbolicLinkName, L"\\DosDevices\\KD5Link2");

	push	OFFSET FLAT:??_C@_1CK@KCDJMENH@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAK?$AAD?$AA5?$AAL?$AAi?$AAn?$AAk?$AA2@
	lea	eax, DWORD PTR _usSymbolicLinkName$[esp+16]
	push	eax
	call	DWORD PTR __imp__RtlInitUnicodeString@8

; 143  :     IoDeleteSymbolicLink(&usSymbolicLinkName);

	lea	ecx, DWORD PTR _usSymbolicLinkName$[esp+12]
	push	ecx
	call	DWORD PTR __imp__IoDeleteSymbolicLink@4

; 144  :     // Отключаем фильтр
; 145  : 	SetKiSTShadowHook(false);

	mov	eax, DWORD PTR ?HookInstalled@@3HA	; HookInstalled
	test	eax, eax
	je	$L10110
	mov	edx, DWORD PTR _NtBuildNumber
	cmp	WORD PTR [edx], 2600			; 00000a28H
	jne	SHORT $L10110
	push	esi
	call	?FindShadowTable@@YGPAU_SERVICE_DESCRIPTOR_TABLE@@XZ ; FindShadowTable
	mov	esi, eax
	push	esi
	push	OFFSET FLAT:??_C@_0CE@BOCCBFKI@KeServiceDescriptorTableShadow?5?$DN@
	call	_DbgPrint
	add	esp, 8
	test	esi, esi
	je	SHORT $L10129
	mov	eax, DWORD PTR [esi+24]
	push	eax
	push	OFFSET FLAT:??_C@_0DJ@COADGJJP@KeServiceDescriptorTableShadow?9?$DO@
	call	_DbgPrint
	mov	ecx, DWORD PTR [esi+16]
	push	ecx
	push	OFFSET FLAT:??_C@_0DJ@MOCCDNF@KeServiceDescriptorTableShadow?9?$DO@
	call	_DbgPrint
	add	esp, 16					; 00000010H
	call	DWORD PTR __imp__KeRaiseIrqlToDpcLevel@0
	mov	cl, al
	mov	eax, cr0
	mov	DWORD PTR _OldCR0$10123[esp+16], eax
	and	eax, -65537				; fffeffffH
	mov	cr0, eax
	mov	edx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR ?OldPeekMessage@@3P6GHPAUtagMSG@@KKKK@ZA ; OldPeekMessage
	mov	DWORD PTR [edx+1896], eax
	mov	DWORD PTR ?HookInstalled@@3HA, 0	; HookInstalled
	mov	eax, DWORD PTR _OldCR0$10123[esp+16]
	mov	cr0, eax
	call	DWORD PTR __imp_@KfLowerIrql@4
$L10129:
	pop	esi
$L10110:

; 146  :     IoDeleteDevice(DriverObject->DeviceObject);

	mov	ecx, DWORD PTR _DriverObject$[esp+8]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	DWORD PTR __imp__IoDeleteDevice@4

; 147  :  }

	add	esp, 12					; 0000000cH
	ret	4
?DriverUnload@@YGXPAU_DRIVER_OBJECT@@@Z ENDP		; DriverUnload
_TEXT	ENDS
PUBLIC	?DispatchCreateCloseControl@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z ; DispatchCreateCloseControl
PUBLIC	??_C@_0O@NHKJCBKH@Device?5Open?5?$CB?$AA@	; `string'
EXTRN	__imp_@IofCompleteRequest@8:NEAR
;	COMDAT ??_C@_0O@NHKJCBKH@Device?5Open?5?$CB?$AA@
CONST	SEGMENT
??_C@_0O@NHKJCBKH@Device?5Open?5?$CB?$AA@ DB 'Device Open !', 00H ; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?DispatchCreateCloseControl@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z
_TEXT	SEGMENT
_pDeviceObject$ = 8					; size = 4
_pIrp$ = 12						; size = 4
?DispatchCreateCloseControl@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z PROC NEAR ; DispatchCreateCloseControl, COMDAT

; 153  : {

	push	ebx
	push	esi
	push	edi

; 154  : 	PIO_STACK_LOCATION pisl;
; 155  : 	DWORD              dInfo = 0;
; 156  : 	NTSTATUS           ns    = STATUS_NOT_IMPLEMENTED; // Код возврата
; 157  : 
; 158  : 	// Получаем размещение IRP стека
; 159  : 	pisl = IoGetCurrentIrpStackLocation (pIrp);

	mov	edi, DWORD PTR _pIrp$[esp+8]
	mov	ebx, DWORD PTR [edi+96]

; 160  : 	zDbgPrint("Device Open !");	

	push	OFFSET FLAT:??_C@_0O@NHKJCBKH@Device?5Open?5?$CB?$AA@
	mov	esi, -1073741822			; c0000002H
	call	_DbgPrint

; 161  : 	// Проверяем код поддерживаемых функций
; 162  : 	switch (pisl->MajorFunction)

	movzx	eax, BYTE PTR [ebx]
	add	esp, 4
	sub	eax, 0
	je	SHORT $L10015
	sub	eax, 2
	je	SHORT $L10015
	sub	eax, 16					; 00000010H
	jne	SHORT $L10012
$L10015:

; 163  : 	{
; 164  : 	case IRP_MJ_CREATE:
; 165  : 	case IRP_MJ_CLEANUP:
; 166  : 	case IRP_MJ_CLOSE:
; 167  : 		{
; 168  : 			ns = STATUS_SUCCESS;

	xor	esi, esi
$L10012:

; 169  : 			break;
; 170  : 		}
; 171  : 	}
; 172  : 
; 173  : 	// Завершаем IRP запрос
; 174  : 	pIrp->IoStatus.Status      = ns;
; 175  : 	pIrp->IoStatus.Information = dInfo;
; 176  : 	IoCompleteRequest (pIrp, IO_NO_INCREMENT);

	xor	dl, dl
	mov	ecx, edi
	mov	DWORD PTR [edi+24], esi
	mov	DWORD PTR [edi+28], 0
	call	DWORD PTR __imp_@IofCompleteRequest@8
	pop	edi

; 177  : 	return ns;

	mov	eax, esi
	pop	esi
	pop	ebx

; 178  : }

	ret	8
?DispatchCreateCloseControl@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z ENDP ; DispatchCreateCloseControl
_TEXT	ENDS
PUBLIC	?DispatchControl@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z ; DispatchControl
PUBLIC	??_C@_0BE@BNJDKDLD@IoControlCode?5?$DN?5?$CFx?6?$AA@ ; `string'
;	COMDAT ??_C@_0BE@BNJDKDLD@IoControlCode?5?$DN?5?$CFx?6?$AA@
CONST	SEGMENT
??_C@_0BE@BNJDKDLD@IoControlCode?5?$DN?5?$CFx?6?$AA@ DB 'IoControlCode = '
	DB	'%x', 0aH, 00H				; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?DispatchControl@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z
_TEXT	SEGMENT
_pDeviceObject$ = 8					; size = 4
_OldCR0$10148 = 12					; size = 4
_pIrp$ = 12						; size = 4
?DispatchControl@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z PROC NEAR ; DispatchControl, COMDAT

; 183  : {

	push	ebx

; 184  : 	PIO_STACK_LOCATION pisl;
; 185  : 	DWORD              dInfo = 0;
; 186  : 	NTSTATUS           ns    = STATUS_NOT_IMPLEMENTED; // Код возврата
; 187  : 	// Получение расположения IRP стека
; 188  : 	pisl = IoGetCurrentIrpStackLocation (pIrp);
; 189  : 
; 190  : 	// Код управление 
; 191  : 	ULONG  IoControlCode		  = pisl->Parameters.DeviceIoControl.IoControlCode;

	mov	ebx, DWORD PTR _pIrp$[esp]
	mov	eax, DWORD PTR [ebx+96]
	push	esi
	mov	esi, DWORD PTR [eax+12]
	push	edi

; 192  : 	zDbgPrint("IoControlCode = %x\n", IoControlCode);	

	push	esi
	push	OFFSET FLAT:??_C@_0BE@BNJDKDLD@IoControlCode?5?$DN?5?$CFx?6?$AA@
	mov	edi, -1073741822			; c0000002H
	call	_DbgPrint
	add	esp, 8

; 193  : 
; 194  : 	// IOCTL_SETKBDHOOK - установка перехватчка
; 195  : 	if (IoControlCode == IOCTL_SETKBDHOOK) {

	cmp	esi, 2236416				; 00222000H
	jne	SHORT $L10027

; 196  : 	  // Устанавливаем перехватчик
; 197  :       ns  = SetKiSTShadowHook(true);

	push	1
	call	?SetKiSTShadowHook@@YGJH@Z		; SetKiSTShadowHook

; 198  : 	  // Блокируем выгрузку драйвера
; 199  : 	  pDeviceObject->DriverObject->DriverUnload = NULL;        

	mov	ecx, DWORD PTR _pDeviceObject$[esp+8]
	mov	edx, DWORD PTR [ecx+8]
	mov	edi, eax
	mov	DWORD PTR [edx+52], 0

; 200  : 	}
; 201  : 
; 202  : 	// IOCTL_REMOVEKBDHOOK - удаление перехватчка
; 203  : 	if (IoControlCode == IOCTL_REMOVEKBDHOOK) {

	jmp	$L10028
$L10027:
	cmp	esi, 2236420				; 00222004H
	jne	$L10028

; 204  : 	  // Отключаем перехватчик
; 205  :       ns  = SetKiSTShadowHook(false);

	mov	eax, DWORD PTR ?HookInstalled@@3HA	; HookInstalled
	test	eax, eax
	je	SHORT $L10154
	mov	eax, DWORD PTR _NtBuildNumber
	cmp	WORD PTR [eax], 2600			; 00000a28H
	jne	SHORT $L10154
	call	?FindShadowTable@@YGPAU_SERVICE_DESCRIPTOR_TABLE@@XZ ; FindShadowTable
	mov	esi, eax
	push	esi
	push	OFFSET FLAT:??_C@_0CE@BOCCBFKI@KeServiceDescriptorTableShadow?5?$DN@
	call	_DbgPrint
	add	esp, 8
	test	esi, esi
	jne	SHORT $L10147
$L10154:
	mov	edi, -1073741823			; c0000001H
	jmp	SHORT $L10135
$L10147:
	mov	ecx, DWORD PTR [esi+24]
	push	ecx
	push	OFFSET FLAT:??_C@_0DJ@COADGJJP@KeServiceDescriptorTableShadow?9?$DO@
	call	_DbgPrint
	mov	edx, DWORD PTR [esi+16]
	push	edx
	push	OFFSET FLAT:??_C@_0DJ@MOCCDNF@KeServiceDescriptorTableShadow?9?$DO@
	call	_DbgPrint
	add	esp, 16					; 00000010H
	call	DWORD PTR __imp__KeRaiseIrqlToDpcLevel@0
	mov	cl, al
	mov	eax, cr0
	mov	DWORD PTR _OldCR0$10148[esp+8], eax
	and	eax, -65537				; fffeffffH
	mov	cr0, eax
	mov	eax, DWORD PTR [esi+16]
	mov	edx, DWORD PTR ?OldPeekMessage@@3P6GHPAUtagMSG@@KKKK@ZA ; OldPeekMessage
	mov	DWORD PTR [eax+1896], edx
	mov	DWORD PTR ?HookInstalled@@3HA, 0	; HookInstalled
	mov	eax, DWORD PTR _OldCR0$10148[esp+8]
	mov	cr0, eax
	call	DWORD PTR __imp_@KfLowerIrql@4
$L10135:

; 206  : 	  // Разрешаем выгрузку драйвера
; 207  : 	  pDeviceObject->DriverObject->DriverUnload = DriverUnload;        

	mov	eax, DWORD PTR _pDeviceObject$[esp+8]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+52], OFFSET FLAT:?DriverUnload@@YGXPAU_DRIVER_OBJECT@@@Z ; DriverUnload
$L10028:

; 208  : 	}
; 209  : 
; 210  : 	// Завершение IRP запроса
; 211  : 	pIrp->IoStatus.Status      = ns;
; 212  : 	pIrp->IoStatus.Information = dInfo;
; 213  : 	IoCompleteRequest (pIrp, IO_NO_INCREMENT);

	xor	dl, dl
	mov	ecx, ebx
	mov	DWORD PTR [ebx+24], edi
	mov	DWORD PTR [ebx+28], 0
	call	DWORD PTR __imp_@IofCompleteRequest@8

; 214  : 	return ns;  

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 215  : }

	ret	8
?DispatchControl@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z ENDP ; DispatchControl
_TEXT	ENDS
PUBLIC	?DriverEntry@@YGJPAU_DRIVER_OBJECT@@PAU_UNICODE_STRING@@@Z ; DriverEntry
PUBLIC	??_C@_1BI@MLGDGAJJ@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAK?$AAD?$AA5?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BF@JFBALODB@IoCreateDevice?5error?$AA@	; `string'
PUBLIC	??_C@_0CJ@JPLNHOOH@DriverEntry?3?5IoCreateSymbolicLin@ ; `string'
EXTRN	__imp__IoCreateDevice@28:NEAR
EXTRN	__imp__IoCreateSymbolicLink@8:NEAR
;	COMDAT ??_C@_1BI@MLGDGAJJ@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAK?$AAD?$AA5?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@MLGDGAJJ@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAK?$AAD?$AA5?$AA?$AA@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'\', 00H, 'K', 00H, 'D', 00H, '5', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JFBALODB@IoCreateDevice?5error?$AA@
CONST	SEGMENT
??_C@_0BF@JFBALODB@IoCreateDevice?5error?$AA@ DB 'IoCreateDevice error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@JPLNHOOH@DriverEntry?3?5IoCreateSymbolicLin@
CONST	SEGMENT
??_C@_0CJ@JPLNHOOH@DriverEntry?3?5IoCreateSymbolicLin@ DB 'DriverEntry: I'
	DB	'oCreateSymbolicLink error', 0aH, 00H	; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?DriverEntry@@YGJPAU_DRIVER_OBJECT@@PAU_UNICODE_STRING@@@Z
_TEXT	SEGMENT
_DeviceObject$ = -20					; size = 4
_usDeviceNameUnicodeString$ = -16			; size = 8
_usDeviceLinkUnicodeString$ = -8			; size = 8
_DriverObject$ = 8					; size = 4
_RegistryPath$ = 12					; size = 4
?DriverEntry@@YGJPAU_DRIVER_OBJECT@@PAU_UNICODE_STRING@@@Z PROC NEAR ; DriverEntry, COMDAT

; 220  : {

	sub	esp, 20					; 00000014H
	push	esi

; 221  :     PDEVICE_OBJECT         DeviceObject        = NULL;
; 222  :     NTSTATUS               ntStatus;
; 223  :     UNICODE_STRING         usDeviceNameUnicodeString;
; 224  :     UNICODE_STRING         usDeviceLinkUnicodeString;
; 225  : 
; 226  :     
; 227  :     // Подготовка Unicode строк
; 228  :     RtlInitUnicodeString (&usDeviceNameUnicodeString,
; 229  :                           L"\\Device\\KD5");

	mov	esi, DWORD PTR __imp__RtlInitUnicodeString@8
	push	edi
	push	OFFSET FLAT:??_C@_1BI@MLGDGAJJ@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAK?$AAD?$AA5?$AA?$AA@
	lea	eax, DWORD PTR _usDeviceNameUnicodeString$[esp+32]
	push	eax
	mov	DWORD PTR _DeviceObject$[esp+36], 0
	call	esi

; 230  :     RtlInitUnicodeString (&usDeviceLinkUnicodeString,
; 231  :                           L"\\DosDevices\\KD5Link2" );

	push	OFFSET FLAT:??_C@_1CK@KCDJMENH@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAK?$AAD?$AA5?$AAL?$AAi?$AAn?$AAk?$AA2@
	lea	ecx, DWORD PTR _usDeviceLinkUnicodeString$[esp+32]
	push	ecx
	call	esi

; 232  :     // Создание устройства
; 233  :     ntStatus = IoCreateDevice (DriverObject,
; 234  :                                sizeof(DEVICE_OBJECT),
; 235  :                                &usDeviceNameUnicodeString,
; 236  :                                FILE_DEVICE_UNKNOWN,
; 237  :                                0,
; 238  :                                TRUE,
; 239  :                                &DeviceObject);

	mov	esi, DWORD PTR _DriverObject$[esp+24]
	lea	edx, DWORD PTR _DeviceObject$[esp+28]
	push	edx
	push	1
	push	0
	push	34					; 00000022H
	lea	eax, DWORD PTR _usDeviceNameUnicodeString$[esp+44]
	push	eax
	push	184					; 000000b8H
	push	esi
	call	DWORD PTR __imp__IoCreateDevice@28
	mov	edi, eax

; 240  : 
; 241  :     if (!NT_SUCCESS(ntStatus)) {

	test	edi, edi
	jge	SHORT $L10040

; 242  : 		zDbgPrint("IoCreateDevice error");

	push	OFFSET FLAT:??_C@_0BF@JFBALODB@IoCreateDevice?5error?$AA@
	call	_DbgPrint
	add	esp, 4

; 266  :     DriverObject->DriverUnload  = DriverUnload;
; 267  :     return ntStatus;

	mov	eax, edi
	pop	edi
	pop	esi

; 268  : }

	add	esp, 20					; 00000014H
	ret	8
$L10040:

; 243  :         return ntStatus;
; 244  :     }
; 245  :     
; 246  :     // Создание символьной ссылки     
; 247  :     ntStatus = IoCreateSymbolicLink (&usDeviceLinkUnicodeString,
; 248  :                                      &usDeviceNameUnicodeString );

	lea	ecx, DWORD PTR _usDeviceNameUnicodeString$[esp+28]
	push	ecx
	lea	edx, DWORD PTR _usDeviceLinkUnicodeString$[esp+32]
	push	edx
	call	DWORD PTR __imp__IoCreateSymbolicLink@8
	mov	edi, eax

; 249  :     if (!NT_SUCCESS(ntStatus)) {

	test	edi, edi
	jge	SHORT $L10046

; 250  : 		DbgPrint("DriverEntry: IoCreateSymbolicLink error\n");

	push	OFFSET FLAT:??_C@_0CJ@JPLNHOOH@DriverEntry?3?5IoCreateSymbolicLin@
	call	_DbgPrint

; 251  :         IoDeleteDevice(DeviceObject);

	mov	eax, DWORD PTR _DeviceObject$[esp+32]
	add	esp, 4
	push	eax
	call	DWORD PTR __imp__IoDeleteDevice@4

; 266  :     DriverObject->DriverUnload  = DriverUnload;
; 267  :     return ntStatus;

	mov	eax, edi
	pop	edi
	pop	esi

; 268  : }

	add	esp, 20					; 00000014H
	ret	8
$L10046:

; 252  :         return ntStatus;
; 253  :     }
; 254  :     
; 255  :     if(!NT_SUCCESS(ntStatus)) {
; 256  :       IoDeleteDevice (DeviceObject);  
; 257  :       return ntStatus;
; 258  :     }
; 259  :     
; 260  : 		// Подключение обработчика DEVICE_CONTROL	 
; 261  : 		DriverObject->MajorFunction [IRP_MJ_DEVICE_CONTROL] = DispatchControl;
; 262  : 		// Подключение обработчиков CREATE/CLOSE/CLEANUP
; 263  : 		DriverObject->MajorFunction [IRP_MJ_CLEANUP] =
; 264  : 		DriverObject->MajorFunction [IRP_MJ_CREATE] = 
; 265  : 		DriverObject->MajorFunction [IRP_MJ_CLOSE] =  DispatchCreateCloseControl;

	mov	eax, OFFSET FLAT:?DispatchCreateCloseControl@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z ; DispatchCreateCloseControl
	mov	DWORD PTR [esi+64], eax
	mov	DWORD PTR [esi+56], eax
	mov	DWORD PTR [esi+128], eax

; 266  :     DriverObject->DriverUnload  = DriverUnload;
; 267  :     return ntStatus;

	mov	eax, edi
	pop	edi
	mov	DWORD PTR [esi+112], OFFSET FLAT:?DispatchControl@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z ; DispatchControl
	mov	DWORD PTR [esi+52], OFFSET FLAT:?DriverUnload@@YGXPAU_DRIVER_OBJECT@@@Z ; DriverUnload
	pop	esi

; 268  : }

	add	esp, 20					; 00000014H
	ret	8
?DriverEntry@@YGJPAU_DRIVER_OBJECT@@PAU_UNICODE_STRING@@@Z ENDP ; DriverEntry
_TEXT	ENDS
END
