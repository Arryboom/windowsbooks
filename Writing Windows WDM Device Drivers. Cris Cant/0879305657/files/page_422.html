<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
	<html>
		<head>
			<title>page_422</title>
			<link rel="stylesheet" href="reset.css" type="text/css" media="all">
			<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
		</head>
		<body>
		<table summary="top nav" border="0" width="100%">
			<tr>
				<td align="left" width="30%" style="background: #EEF3E2"><a style="color: blue; font-size: 120%; font-weight: bold; text-decoration: none; font-family: verdana;" href="page_421.html">&lt;&nbsp;previous page</a></td>
				<td id="ebook_previous" align="center" width="40%" style="background: #EEF3E2"><strong style="color: #2F4F4F; font-size: 120%;">page_422</strong></td>
				<td align="right" width="30%" style="background: #EEF3E2"><a style="color: blue; font-size: 120%; font-weight: bold; text-decoration: none; font-family: verdana;" href="page_423.html">next page&nbsp;&gt;</a></td>
			</tr>
		
			<tr>
				<td id="ebook_page" align="left" colspan="3" style="background: #ffffff; padding: 20px;">
    

<table border="0" width="100%" cellpadding="0"><tr><td align="center">
  <table border="0" cellpadding="2" cellspacing="0" width="100%"><tr><td align="left"></td>
  <td align="right"></td>
  </tr></table></td>
</tr><tr><td align="left">



<p>
</p><table border="0" cellspacing="0" cellpadding="0" width="100%"><tr><td align="right"><font face="Times New Roman, Times, Serif" size="2" color="#FF0000">Page 422</font></td></tr></table><table border="0" cellspacing="0" cellpadding="0"><tr><td rowspan="5"></td>
  <td colspan="3" height="12"></td>
  <td rowspan="5"></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td></td>
  <td><font face="Times New Roman, Times, Serif" size="3">of the IRP stack size. Use </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">IoGetNextIrpStackLocation</font><font face="Times New Roman, Times, Serif" size="3"> to get the first IRP stack location if you need to set up a completion routine. Call </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">IoFreeIrp</font><font face="Times New Roman, Times, Serif" size="3"> to free an IRP created by </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">IoAllocateIrp</font><font face="Times New Roman, Times, Serif" size="3">.</font></td>
<td></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td colspan="3" height="1"></td>
</tr></table><table border="0" cellspacing="0" cellpadding="0"><tr><td rowspan="5"></td>
  <td colspan="3" height="12"></td>
  <td rowspan="5"></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td></td>
  <td><font face="Times New Roman, Times, Serif" size="3">The old DDK documentation wrongly says that you can call </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">IoInitializeIrp</font><font face="Times New Roman, Times, Serif" size="3"> to reuse an IRP allocated using </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">IoAllocateIrp</font><font face="Times New Roman, Times, Serif" size="3">. You can use this function as long as you preserve the IRP </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3"><i>AllocationFlags</i></font><font face="Times New Roman, Times, Serif" size="3"> field, as shown in Chapter 23. In W2000, you can reuse an IRP created with </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">IoAllocateIrp</font><font face="Times New Roman, Times, Serif" size="3"> using </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">IoReuseIrp</font><font face="Times New Roman, Times, Serif" size="3">.</font></td>
<td></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td colspan="3" height="1"></td>
</tr></table><table border="0" cellspacing="0" cellpadding="0"><tr><td rowspan="5"></td>
  <td colspan="3" height="12"></td>
  <td rowspan="5"></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td></td>
  <td><font face="Times New Roman, Times, Serif" size="3">Multiple USBDI Calls</font></td>
<td></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td colspan="3" height="1"></td>
</tr></table><table border="0" cellspacing="0" cellpadding="0"><tr><td rowspan="5"></td>
  <td colspan="3" height="12"></td>
  <td rowspan="5"></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td></td>
  <td><font face="Times New Roman, Times, Serif" size="3">If you were reading carefully, you will have noticed that the </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">CallUSBDI</font><font face="Times New Roman, Times, Serif" size="3"> routine can only be called at </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">PASSIVE_LEVEL</font><font face="Times New Roman, Times, Serif" size="3">. This means that it cannot be called from a </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">StartIo</font><font face="Times New Roman, Times, Serif" size="3"> routine, which runs at </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">DISPATCH_LEVEL</font><font face="Times New Roman, Times, Serif" size="3">. </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">UsbKbd</font><font face="Times New Roman, Times, Serif" size="3"> makes its USB calls direct from its dispatch routines that run at PASSIVE_LEVEL.</font></td>
<td></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td colspan="3" height="1"></td>
</tr></table><table border="0" cellspacing="0" cellpadding="0"><tr><td rowspan="5"></td>
  <td colspan="3" height="12"></td>
  <td rowspan="5"></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td></td>
  <td><font face="Times New Roman, Times, Serif" size="3">In </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">UsbKbd</font><font face="Times New Roman, Times, Serif" size="3">, it is possible for a user program to issue two overlapped read requests ''simultaneously". This might easily result in the USB class drivers being sent two IRPs for processing at the same time. There is nothing in the documentation that says this is a problem. I suspect that it is not, as the USB class driver will almost certainly serialize requests.</font></td>
<td></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td colspan="3" height="1"></td>
</tr></table><table border="0" cellspacing="0" cellpadding="0"><tr><td rowspan="5"></td>
  <td colspan="3" height="12"></td>
  <td rowspan="5"></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td></td>
  <td><font face="Times New Roman, Times, Serif" size="3">If you feel that you ought to serialize your USBDI calls, you will have to use a </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">StartIo</font><font face="Times New Roman, Times, Serif" size="3"> routine. A single prebuilt IRP can be reused for each call. Chapter 23 shows how to build, use, and free such an IRP.</font></td>
<td></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td colspan="3" height="1"></td>
</tr></table><table border="0" cellspacing="0" cellpadding="0"><tr><td rowspan="5"></td>
  <td colspan="3" height="12"></td>
  <td rowspan="5"></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td></td>
  <td><font face="Times New Roman, Times, Serif" size="3">In many cases, it might be useful to send off a series of IRPs to the USB class drivers. As there will usually be a spare IRP queued up for processing, no incoming data will be lost.</font></td>
<td></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td colspan="3" height="1"></td>
</tr></table><table border="0" cellspacing="0" cellpadding="0"><tr><td rowspan="5"></td>
  <td colspan="3" height="17"></td>
  <td rowspan="5"></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td></td>
  <td><font face="Times New Roman, Times, Serif" size="3">Talking USB</font></td>
<td></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td colspan="3" height="1"></td>
</tr></table><table border="0" cellspacing="0" cellpadding="0"><tr><td rowspan="5"></td>
  <td colspan="3" height="12"></td>
  <td rowspan="5"></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td></td>
  <td><font face="Times New Roman, Times, Serif" size="3"><i>Initializing a USB Device</i></font></td>
<td></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td colspan="3" height="1"></td>
</tr></table><table border="0" cellspacing="0" cellpadding="0"><tr><td rowspan="5"></td>
  <td colspan="3" height="12"></td>
  <td rowspan="5"></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td></td>
  <td><font face="Times New Roman, Times, Serif" size="3">There are several jobs that a USB client driver must do to initialize its connection to its device. The </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">UsbKbd</font><font face="Times New Roman, Times, Serif" size="3"> driver does these jobs in its Create IRP handler. However, most USB drivers will want to initialize their device when processing the <i>Start Device</i> Plug and Play IRP.</font></td>
<td></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td colspan="3" height="1"></td>
</tr></table><table border="0" cellspacing="0" cellpadding="0"><tr><td rowspan="5"></td>
  <td colspan="3" height="12"></td>
  <td rowspan="5"></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td></td>
  <td><font face="Times New Roman, Times, Serif" size="3">1. Check device enabled. Reset and enable the device, if necessary.</font></td>
<td></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td colspan="3" height="1"></td>
</tr></table><table border="0" cellspacing="0" cellpadding="0"><tr><td rowspan="5"></td>
  <td colspan="3" height="12"></td>
  <td rowspan="5"></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td></td>
  <td><font face="Times New Roman, Times, Serif" size="3">2. Select one interface in one of the configurations.</font></td>
<td></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td colspan="3" height="1"></td>
</tr></table><table border="0" cellspacing="0" cellpadding="0"><tr><td rowspan="5"></td>
  <td colspan="3" height="12"></td>
  <td rowspan="5"></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td></td>
  <td><font face="Times New Roman, Times, Serif" size="3">3. Possibly read other descriptors, such as the string-, class-, or vendor-specific descriptors.</font></td>
<td></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td colspan="3" height="1"></td>
</tr></table><table border="0" cellspacing="0" cellpadding="0"><tr><td rowspan="5"></td>
  <td colspan="3" height="12"></td>
  <td rowspan="5"></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td></td>
  <td><font face="Times New Roman, Times, Serif" size="3">4. Talk to your device to issue whatever commands are relevant, get device status, and initialize pipes.</font></td>
<td></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td colspan="3" height="1"></td>
</tr></table><table border="0" cellspacing="0" cellpadding="0"><tr><td rowspan="5"></td>
  <td colspan="3" height="12"></td>
  <td rowspan="5"></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td></td>
  <td><font face="Times New Roman, Times, Serif" size="3">Device Reset</font></td>
<td></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td colspan="3" height="1"></td>
</tr></table><table border="0" cellspacing="0" cellpadding="0"><tr><td rowspan="5"></td>
  <td colspan="3" height="12"></td>
  <td rowspan="5"></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td></td>
  <td><font face="Times New Roman, Times, Serif" size="3">Listing 21.3 shows how </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">UsbKbd</font><font face="Times New Roman, Times, Serif" size="3"> resets its device in routine </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">UsbResetDevice</font><font face="Times New Roman, Times, Serif" size="3"> when a Win32 program opens a handle to it. </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">UsbGetPortStatus</font><font face="Times New Roman, Times, Serif" size="3"> issues </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">IOCTL_INTERNAL_USB_GET_PORT_STATUS</font><font face="Times New Roman, Times, Serif" size="3"> to retrieve the port status bits. </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">UsbResetDevice</font><font face="Times New Roman, Times, Serif" size="3"> checks the </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">USBD_PORT_CONNECTED</font><font face="Times New Roman, Times, Serif" size="3"> and </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">USBD_PORT_ENABLED</font><font face="Times New Roman, Times, Serif" size="3"> bits, and calls </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">UsbResetPort</font><font face="Times New Roman, Times, Serif" size="3">, if necessary. </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">UsbResetPort</font><font face="Times New Roman, Times, Serif" size="3"> simply issues </font><font face="Courier New, Courier, Mono New, Courier, Mono" size="3">IOCTL_INTERNAL_USB_RESET_PORT</font><font face="Times New Roman, Times, Serif" size="3"> to the USB class drivers.</font><font face="Times New Roman, Times, Serif" size="3" color="#FFFF00"></font></td>
<td></td>
</tr><tr><td colspan="3"></td>
</tr><tr><td colspan="3" height="1"></td>
</tr></table>





</td>
</tr></table><p><font size="0">
</font></p>
 




  </td>
			</tr>
	
			<tr>
				<td align="left" width="30%" style="background: #EEF3E2"><a style="color: blue; font-size: 120%; font-weight: bold; text-decoration: none; font-family: verdana;" href="page_421.html">&lt;&nbsp;previous page</a></td>
				<td id="ebook_next" align="center" width="40%" style="background: #EEF3E2"><strong style="color: #2F4F4F; font-size: 120%;">page_422</strong></td>
				<td align="right" width="30%" style="background: #EEF3E2"><a style="color: blue; font-size: 120%; font-weight: bold; text-decoration: none; font-family: verdana;" href="page_423.html">next page&nbsp;&gt;</a></td>
			</tr>
		</table>
		</body>
	</html>