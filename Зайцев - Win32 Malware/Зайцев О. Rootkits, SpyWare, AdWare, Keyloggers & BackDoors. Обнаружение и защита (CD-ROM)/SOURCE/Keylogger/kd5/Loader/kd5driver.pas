unit kd5driver;

interface
uses
  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
  Dialogs, winsvc, StdCtrls;
type

 TKD5Driver = class
  private
    FEnabled: boolean;
    FLoaded: boolean;
    FDriverPath: string;
    ServiceAPILoaded : boolean;
    FDriverName: string;
    procedure SetEnabled(const Value: boolean);
    procedure SetDriverPath(const Value: string);
    procedure SetDriverName(const Value: string);
  public
   DriverLinkName : string;
   constructor Create;
   function CheckDriverEnabled : boolean;
   function InstallDriver   : boolean;
   function LoadDriver      : boolean;
   function UnLoadDriver    : boolean;
   function UnInstallDriver : boolean;
   function CallDriver_SETHOOK: boolean;
   function CallDriver_DELHOOK: boolean;
  published
   property Enabled : boolean read FEnabled write SetEnabled;
   property Loaded  : boolean read FLoaded;
   property DriverPath : string read FDriverPath write SetDriverPath;
   property DriverName : string read FDriverName write SetDriverName;
 end;

implementation
type
 // Прототипы функций
 TzOpenSCManager      = function (lpMachineName, lpDatabaseName: PChar; dwDesiredAccess: DWORD): SC_HANDLE; stdcall;
 TzEnumServicesStatus = function (hSCManager: SC_HANDLE; dwServiceType, dwServiceState: DWORD; var lpServices: TEnumServiceStatus; cbBufSize: DWORD; var pcbBytesNeeded, lpServicesReturned, lpResumeHandle: DWORD): BOOL stdcall;
 TzQueryServiceConfig = function (hService: SC_HANDLE; lpServiceConfig: PQueryServiceConfig; cbBufSize: DWORD; var pcbBytesNeeded: DWORD): BOOL stdcall;
 TzCloseServiceHandle = function (hSCObject: SC_HANDLE): BOOL stdcall;
 TzCreateService      = function (hSCManager: SC_HANDLE; lpServiceName, lpDisplayName: PChar;
                                  dwDesiredAccess, dwServiceType, dwStartType, dwErrorControl: DWORD;
                                  lpBinaryPathName, lpLoadOrderGroup: PChar; lpdwTagId: LPDWORD; lpDependencies,
                                  lpServiceStartName, lpPassword: PChar): SC_HANDLE; stdcall;
 TzOpenService        = function (hSCManager: SC_HANDLE; lpServiceName: PChar; dwDesiredAccess: DWORD): SC_HANDLE stdcall;
 TzStartService       = function (hService: SC_HANDLE; dwNumServiceArgs: DWORD; var lpServiceArgVectors: PChar): BOOL; stdcall;
 TzDeleteService      = function (hService: SC_HANDLE): BOOL; stdcall;
 TzControlService     = function (hService: SC_HANDLE; dwControl: DWORD;
                                  var lpServiceStatus: TServiceStatus): BOOL; stdcall;
var
 zOpenSCManager          : TzOpenSCManager      = nil;
 zEnumServicesStatus     : TzEnumServicesStatus = nil;
 zQueryServiceConfig     : TzQueryServiceConfig = nil;
 zCloseServiceHandle     : TzCloseServiceHandle = nil;
 zCreateService          : TzCreateService      = nil;
 zOpenService            : TzOpenService        = nil;
 zStartService           : TzStartService       = nil;
 zDeleteService          : TzDeleteService      = nil;
 zControlService         : TzControlService     = nil;

{ TKD5Driver }
function CTL_CODE(ADeviceType, AFunction, AMethod, AAccess : DWORD) : dword;
begin
 Result := ((ADeviceType) shl 16) or ((AAccess) shl 14) or ((AFunction) shl 2) or (AMethod);
end;

// Проверка платформы (true - платформа NT)
function ISNT : boolean;
var
 Ver  : TOSVersionInfo;
begin
 Result := False;
 Ver.dwOSVersionInfoSize := SizeOf(TOSVersionInfo);
 GetVersionEx(Ver);
 case Ver.dwPlatformId of
  VER_PLATFORM_WIN32_NT      : Result := True;   //Windows NT - подходит
  VER_PLATFORM_WIN32_WINDOWS : Result := False;  //Windows 9x-Me - подходит
  VER_PLATFORM_WIN32s        : Result := False;  //Windows 3.x - не подходит
 end;
end;

function LoadServiceManagerAPI : boolean;
var
 LibHandle    : THandle;
begin
 Result := false;
 if @zOpenSCManager = nil then begin
  LibHandle := 0;
  zOpenSCManager      := nil;
  zEnumServicesStatus := nil;
  zQueryServiceConfig := nil;
  zCloseServiceHandle := nil;
  zOpenService        := nil;
  zStartService       := nil;
  zDeleteService      := nil;
  zControlService     := nil;
  // Загрузка таблицы сервисов производится только для NT
  if ISNT then begin
   LibHandle := LoadLibrary('advapi32.dll');
   if LibHandle = 0 then exit;
   @zOpenSCManager      := GetProcAddress(LibHandle, 'OpenSCManagerA');
   @zOpenService        := GetProcAddress(LibHandle, 'OpenServiceA');
   @zEnumServicesStatus := GetProcAddress(LibHandle, 'EnumServicesStatusA');
   @zQueryServiceConfig := GetProcAddress(LibHandle, 'QueryServiceConfigA');
   @zCloseServiceHandle := GetProcAddress(LibHandle, 'CloseServiceHandle');
   @zStartService       := GetProcAddress(LibHandle, 'StartServiceA');
   @zCreateService      := GetProcAddress(LibHandle, 'CreateServiceA');
   @zDeleteService      := GetProcAddress(LibHandle, 'DeleteService');
   @zControlService     := GetProcAddress(LibHandle, 'ControlService');
  end;
 end;
 // Проверка результата загрузки
 Result := (@zOpenSCManager <> nil) and (@zOpenService <> nil) and
               (@zEnumServicesStatus <> nil) and (@zQueryServiceConfig <> nil) and
               (@zCloseServiceHandle <> nil) and (@zStartService <> nil) and
               (@zCreateService <> nil);
end;

function TKD5Driver.CallDriver_SETHOOK: boolean;
var
 hDriver : THandle;
 BytesReturned : Cardinal;
 IOCode, dw : DWord;
 Res        : boolean;
begin
 Result := false;
 if not(Loaded) then exit;
 // Открываем драйвер
 hDriver := CreateFile(PChar(DriverLinkName),GENERIC_READ, 0, nil, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,0);
 if hDriver = INVALID_HANDLE_VALUE then exit;
 dw := 0;
 IOCode := CTL_CODE($022,$800,0,0);
 Result := DeviceIoControl(hDriver, IOCode,
                        @dw, sizeof(dw),
                        @dw, sizeof(dw),
                        BytesReturned, nil);
 CloseHandle(hDriver);
end;

function TKD5Driver.CallDriver_DELHOOK: boolean;
var
 hDriver : THandle;
 BytesReturned : Cardinal;
 IOCode, dw : DWord;
 Res        : boolean;
begin
 Result := false;
 if not(Loaded) then exit;
 // Открываем драйвер
 hDriver := CreateFile(PChar(DriverLinkName),GENERIC_READ, 0, nil, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,0);
 if hDriver = INVALID_HANDLE_VALUE then exit;
 dw := 0;
 IOCode := CTL_CODE($022,$801,0,0);
 Result := DeviceIoControl(hDriver, IOCode,
                        @dw, sizeof(dw),
                        @dw, sizeof(dw),
                        BytesReturned, nil);
 CloseHandle(hDriver);
end;

function TKD5Driver.CheckDriverEnabled: boolean;
begin
 Result := FEnabled and ServiceAPILoaded;
end;

constructor TKD5Driver.Create;
begin
 FLoaded   := false;
 FEnabled  := true;
 ServiceAPILoaded := LoadServiceManagerAPI;
 DriverLinkName := '\\.\\KD5Link'; 
 DriverName := 'kd5.sys';
end;

function TKD5Driver.InstallDriver: boolean;
var
 SCManagerHandle, SCHandle : THandle;
begin
 Result := false;
 if not(CheckDriverEnabled) then exit;
 // 1. Подключение к менеджеру сервисов
 SCManagerHandle := zOpenSCManager(nil, nil, SC_MANAGER_ALL_ACCESS);
 if SCManagerHandle = NULL then exit;
 // 2. Создание
 SCHandle := zCreateService(SCManagerHandle, 'KD5', 'KD5 Demo',
               SERVICE_START or SERVICE_STOP or SERVICE_ALL_ACCESS,
               SERVICE_KERNEL_DRIVER, SERVICE_DEMAND_START,
               SERVICE_ERROR_NORMAL, PChar(DriverPath+DriverName),
               nil, nil, nil, nil, nil);
 Result := (SCHandle <> 0);
 // 3. Отключение от менеджера сервисов
 zCloseServiceHandle(SCHandle);
 zCloseServiceHandle(SCManagerHandle);
end;

function TKD5Driver.LoadDriver: boolean;
var
 SCManagerHandle, SCHandle : THandle;
 pcAgr : PChar;
 err   : integer;
begin
 Result := false;
 if not(CheckDriverEnabled) then exit;
 // 1. Подключение к менеджеру сервисов
 SCManagerHandle := zOpenSCManager(nil, nil, SC_MANAGER_ALL_ACCESS);
 if SCManagerHandle = NULL then exit;
 // 2. Создание
 SCHandle := zOpenService(SCManagerHandle, 'KD5',
                         SERVICE_START or
                         SERVICE_STOP or
                         SERVICE_ALL_ACCESS);
 pcAgr := nil;
 Result := zStartService(SCHandle, 0, pcAgr);
 // Получение кода последней ошибки
 err    := GetLastError;
 // Проверим причину ошибки - может быть, сервис драйвер уже загружен
 if not(Result) and (err = ERROR_SERVICE_ALREADY_RUNNING) then
  Result := true;
 FLoaded := Result;
 // 3. Отключение от менеджера сервисов
 zCloseServiceHandle(SCHandle);
 zCloseServiceHandle(SCManagerHandle);
end;

procedure TKD5Driver.SetDriverName(const Value: string);
begin
  FDriverName := Value;
end;

procedure TKD5Driver.SetDriverPath(const Value: string);
begin
  FDriverPath := Value;
end;

procedure TKD5Driver.SetEnabled(const Value: boolean);
begin
  FEnabled := Value;
end;

function TKD5Driver.UnInstallDriver: boolean;
var
 SCManagerHandle, SCHandle : THandle;
begin
 Result := false;
 if not(CheckDriverEnabled) then exit;
 // 1. Подключение к менеджеру сервисов
 SCManagerHandle := zOpenSCManager(nil, nil, SC_MANAGER_ALL_ACCESS);
 if SCManagerHandle = NULL then exit;
 // 2. Открытие
 SCHandle := zOpenService(SCManagerHandle, 'KD5',
                         SERVICE_START or
                         SERVICE_STOP or
                         SERVICE_ALL_ACCESS);
 // 3. Удаление
 Result  := zDeleteService(SCHandle);

 FLoaded := false;
 // 4. Отключение от менеджера сервисов
 zCloseServiceHandle(SCHandle);
 zCloseServiceHandle(SCManagerHandle);
end;

function TKD5Driver.UnLoadDriver: boolean;
var
 SCManagerHandle, SCHandle : THandle;
 ServiceStatus             : TServiceStatus;
begin
 Result := false;
 if not(CheckDriverEnabled) then exit;
 // 1. Подключение к менеджеру сервисов
 SCManagerHandle := zOpenSCManager(nil, nil, SC_MANAGER_ALL_ACCESS);
 if SCManagerHandle = NULL then exit;
 // 2. Открытие
 SCHandle := zOpenService(SCManagerHandle, 'KD5',
                         SERVICE_START or
                         SERVICE_STOP or
                         SERVICE_ALL_ACCESS);
 // 3. Остановка
 Result  := zControlService(SCHandle, SERVICE_CONTROL_STOP, ServiceStatus);
 FLoaded := false;
 // 4. Отключение от менеджера сервисов
 zCloseServiceHandle(SCHandle);
 zCloseServiceHandle(SCManagerHandle);
end;

begin
 LoadServiceManagerAPI;
end.
